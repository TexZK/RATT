% VDE Template for EUSAR Papers
% Provided by Barbara Lang und Siegmar Lampe
% University of Bremen, January 2002
% English version by Jens Fischer
% German Aerospace Center (DLR), December 2005
% Additional modifications by Matthias Wei{\ss}
% FGAN, January 2009

%-----------------------------------------------------------------------------
% Type of publication
\documentclass[a4paper,10pt]{article}
%-----------------------------------------------------------------------------
% Other packets: Most packets may be downloaded from www.dante.de and
% "tcilatex.tex" can be found at (December 2005):
% http://www.mackichan.com/techtalk/v30/UsingFloat.htm
% Not all packets are necessarily needed:
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
%\usepackage{ngerman} % in german language if required
\usepackage{hyperref}
\usepackage[nooneline,bf,hypcap,font=small]{caption} % Figure descriptions from left margin
\usepackage{times}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{epstopdf}
\usepackage{mdwlist}
\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{listings}
\usepackage{mdframed}
\input{tcilatex}
%-----------------------------------------------------------------------------
% Page Setup
\textheight24cm \textwidth17cm \columnsep6mm
\oddsidemargin-5mm                 % depending on print drivers!
\evensidemargin-5mm                % required margin size: 2cm
\headheight0cm \headsep0cm \topmargin0cm \parindent0cm
\pagestyle{empty}                  % delete footer and header
%-----------------------------------------------------------------------------
% Environment definitions
\newenvironment*{mytitle}{\begin{LARGE}\bf}{\end{LARGE}\\}%
\newenvironment*{mysubtitle}{\bf}{\\[1.5ex]}%
\newenvironment*{myabstract}{\begin{Large}\bf}{\end{Large}\\[2.5ex]}%
%-----------------------------------------------------------------------------
% Using Pictures and tables:
% - Instead "table" write "tablehere" without parameters
% - Instead "figure" write "figurehere " without parameters
% - Please insert a blank line before and after \begin{figuerhere} ... \end{figurehere}
%
% CAUTION:   The first reference to a figure/table in the text should be formatted fat.
%
%\begin{figurehere}
%  \centering
%  \includegraphics[width=8cm, height=4cm]{./eps/placeholder.eps}
%  \caption{Some single-column figure caption.}
%  \label{fig:myfigure1}
%\end{figurehere}
%
%\begin{figure*}[t]
%  \centering
%  \includegraphics[width=16cm, height=4cm]{./eps/placeholder.eps}
%  \caption{Some wide-figure caption.}
%  \label{fig:myfigure2}
%\end{figure*}

\makeatletter
\newenvironment{tablehere}{\def\@captype{table}\vspace{2ex}}{\vspace{2ex}}
\newenvironment{figurehere}{\def\@captype{figure}\vspace{2ex}}{\vspace{2ex}}
\makeatother

\newcommand{\TODO}{\textbf{TODO\dots\ }}
\newcommand{\CITEME}{\textbf{[CITEME]}}
\newcommand{\INSFIG}{\textbf{Figure PLACEHOLDER}}
\renewcommand{\thefigure}{\arabic{figure}}
\newcommand{\citef}[1]{\textbf{Figure~\ref{#1}}}
\newcommand{\citet}[1]{\textbf{Table~\ref{#1}}}

\definecolor{darkred}{rgb}{0.5,0.0,0.0}
\definecolor{darkgreen}{rgb}{0.0,0.5,0.0}
\definecolor{darkblue}{rgb}{0.0,0.0,0.5}
\definecolor{lightyellow}{rgb}{1.0,1.0,0.9}

\lstdefinelanguage{simpleXML}
{
	tabsize=2,
	breaklines=true,
	basicstyle=\scriptsize\ttfamily\color{darkblue},
	keywordstyle=\color{blue},
	stringstyle=\color{darkred},
	commentstyle=\color{darkgreen},
	showstringspaces=false,	
	morestring=[b]",
	morecomment=[s]{<!--}{-->},
	morecomment=[s]{<?}{?>},
	morekeywords={}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\begin{mytitle}RATT	- Relatively Accurate TurnTable\end{mytitle}
\begin{mysubtitle}Relative turntable motion detection through mouse sensors\end{mysubtitle}
% Please do not insert a line here
\\
Zoppi Andrea\\
Matr. 765662, (andrea.zoppi@mail.polimi.it)\\
\begin{flushright}
\emph{Report for the master course of Embedded Systems}\\
\emph{Reviser: PhD. Patrick Bellasi (bellasi@elet.polimi.it)}
\end{flushright}

Received: <MONTH>, <DAY> 2012\\
\hspace{10ex}

\begin{myabstract} Abstract \end{myabstract}
Cheap jogwheel encoders for emulated DJ turntables are often inaccurate, due
to the low CPR in the order of some tens. Precise encoders are rather expensive
and are not convenient when detecting very fast rotations, because they become
too much accurate for the purpose.

The presented research tries to improve the detection of at least small and
slow relative rotations of the jogwheel, by employing a cheap COTS mouse sensor,
and keep the absolute position or fast rotation with the classic cheap optical
encoder.

A very crude HID demoboard was developed, so that some simple tests were done.
An extended proposal is also described, in order to achieve better performance
and more features, to match those of a commercial DJ controller.


\vspace{4ex}	% Please do not remove or reduce this space here.
\begin{multicols}{2}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{sec:introduction}

In the latest years, the market of digital-DJ related products grew considerably.
By the way, cheap digtital turntable emulation is still tricky, because the
design of a cheap yet accurate jogwheel is still a challenge even with the
technology available today.

It is true that state-of-the-art processing units are very fast, but there are
still issues such as those related to protocol latency, precise and fast plate
motion detection, motion samples interpolation, and so on.

These issues are not a big problem for the average DJ, but they arise when
requiring a higher performance (e.g. \emph{scratch}) while keeping the costs
low.

The proposed approach is based on COTS components called \emph{optical motion/mouse
sensors}, which can provide a very good accuracy when detecting small local
motions, which is a behavior difficult to obtain with cheap encoders.

A simplified verison of the proposal was developed on a crude prototype, just
to check if it is worth at least for the average DJ -- the most demanding ones
do not care about the price of products, and still rely on timecoded vinyl
emulation even tough high CPR optical encoders are available at the same
overall price.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Current market}
\label{sec:current_market}

The common commercial approaches can be divided into two groups: jogwheels
based on optical encoders, and reuse of vinyl turntables (or CD players) as if
they were digital jogwheels. These two technologies will be described in the
following, showing their pros and cons.

There exist also some other ways to emulate turntables, which are currently
still in a niche. For example, there are some touchscreen-based \cite{sm_emulator}
\cite{hn_touchosc} or capacitive \cite{stanton_scs3d} controllers, which
follow the market wave of touchscreen devices.
There are also some evolutions of the optical jogwheels, which are motorized
\cite{denon_sc3900} \cite{numark_v7} and thus more suitable for professionals,
but rather expensive.


%-----------------------------------------------------------------------------
\subsection{Optical encoder jogwheel controllers}

The most common technology for turntable emulation is based on optical encoders.
An optical encoder is a device which detects motion by counting the number of
steps an evenly-marked wheel performs. It is found in almost all purely digital
DJ \emph{controllers}, which in this context are referred to those remote
digital devices used by the DJ to control the user application. Some examples
of commercial controllers with jogwheels can be found in \cite{eks_op}
\cite{pioneer_ddjs1} \cite{vestax_vci400}.

Common jogwheels have a resolution (\emph{CPR, Counts Per Revolution}) in the
order of tens, thus are not suitable for \emph{scratching}, and are usually
addressed only in coarse track navigation, or \emph{bending}.
Even a resolution in the order of some hundreds cannot be enough for scratch
or precise motion tracking. For example, with a 720 CPR encoder it is possible
to detect only motions of half degrees, that for a 12 inches wide wheel is
still low -- keep in mind that a vinyl spins at roughly 150 degrees per second,
and good sampling should require at least 1500 samples per second to track it
decently enough.


\paragraph{System architecture}
The basic architecture of these controllers is shown is \citef{fig:hercules_mp3e2_schematic}.
The controller commonly has a set of input devices -- buttons, knobs,
sliders, \emph{etc.} -- so that the user can \emph{map}\footnote{
	Assign a triggered action to an input event
} these inputs to some software parameters, such as the play/stop events, or
the desired volume level.

A special kind of input device focused throughout this work is the optical
encoder, \TODO which will be described in depth later.

Commonly, there is a also set of output devices -- LEDs, displays -- so that
the user's sight should not always keep switching switched between the computer
monitor and the controller to see what is going on.

All these devices are managed by a MCU, which detects their changes, and
generates meaningful messages to be sent to the DJ software, or receives
messages from the latter.

The communication between the controller and the software is often performed
through an USB bus with HID/USB or MIDI/USB protocols, but some controllers
still rely on the plain old MIDI port (see Section~\ref{sec:controller_protocols}).

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/hercules_mp3e2_schematic.pdf}
	\caption{\emph{Hercules DJ Control MP3 e2} \cite{hercules_djcmp3e2}
	intereface schematic with \textcolor{cyan}{buttons}, \textcolor{red}{incremental encoders},
	\textcolor{green}{sliders and knobs}}
	\label{fig:hercules_mp3e2_schematic}
\end{figurehere}


\paragraph{Wheel architecture}
The wheel is emulated with a so-called \emph{jogwheel}. It is a disc whose
full rotation is divided into equally-spaced angle slices. Each slice is
assigned a code.

Usually, the code is marked on the wheel with holes aligned on circles (see
\citef{fig:encoder_wheels}), so that holes can be detected by light detectors
mounted on the chassis. The light detector is almost always made with a LED
which points towards the disc, and on the other side the light is detected by
a fast phototransistor. These light sensors are positioned so that they can
detect one and only one code per slice.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=0.9\columnwidth]{images/encoder_wheels.pdf}
	\caption{A set of incremental (quadrature) rotary encoder wheels}
	\label{fig:encoder_wheels}
\end{figurehere}

The code is either abolute or relative. Absolute encoders assign a unique code
to each slice, so that it is always possible to know the current wheel angle
by just reading the light detector outputs. Due to the need to have a high
number of bits, the number of holes can also grow exponentially (usually as
the power of two), and the production of precisely aligned marks and sensors
is expensive -- misaligned ones can provide misdetections of the angle, even
with robust codes such as the \emph{Gray code}.

Instead, relative encoders just need the two least significant bits of an
absolute code, thus cheaper to manufacture. On the other hand, it is not
possible to know the absolute rotation without any additional bits. This is
why there is often a mark which signals a full revolution been performed, and
needs an additional flag bit. The particular subset of the Grey code used for
the relative motion detection is called \emph{quadrature code}, because only 4
code sequences (phases) can be generated by moving to the adjacent wheel slice
as seen in \citef{fig:quad_wave}.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=0.9\columnwidth]{images/quad_wave.pdf}
	\caption{Quadrature pattern, going forward left-to-right}
	\label{fig:quad_wave}
\end{figurehere}

An example of jogwheel internals can be seen in \citef{fig:vestax_vci400_jogwheel}.
It is a close-up of the \emph{Vestax VCI-400} \cite{vestax_vci400} jogwheel
architecture, with a high-resolution wheel -- segments can be barely seen --
and an \emph{Agilent HEDS-9700} quadrature encoder.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=0.8\columnwidth]{images/vestax_vci400_jogwheel.pdf}
	\caption{A \emph{Vestax VCI-400} jogwheel being disassembled}
	\label{fig:vestax_vci400_jogwheel}
\end{figurehere}


\paragraph{Motion detection}
When the user turns the wheel, the light detectors can convert the sight of
light into the code assigned to the focused disc slice. The digital code is
then triggered by the MCU through some interrupts, and a message containing
the motion (or even the absolute angle) is sent to the user software.


\paragraph{Pros}
\begin{itemize*}
	\item Easy to manufacture
	\item Code detection is inherently digital
	\item Fast code transitions can be processed easily
	\item A cheap MCU can handle jogwheels as well as all the other digital
		devices commonly found in DJ controllers
\end{itemize*}


\paragraph{Cons}
\begin{itemize*}
	\item Small motions have poor resolution with cheap encoders
	\item High resolution encoders are too much expensive for the purpose
\end{itemize*}


%-----------------------------------------------------------------------------
\subsection{Timecoded media turntable emulation}

An alternative way to emulate a turntable in software is to use a
\emph{timecoded audio track}, which is an audio stream coded so that the
software can read the track position just by decoding the incoming audio
stream.

This technique makes it possible to use existing turntables or CD players to
control the user software, which in turn will emulate the turntable behavior.

The good side of this approach is that a DJ, who already owns turntables or CD
players, can keep using them just by buying a sound card with the appropriate
audio inputs. This way the DJ can have almost perfectly the same old feeling,
because he is still using the same equipment.

On the bad side, vinyls and CDs are very sensible to usage, and decay easily.
This makes the timecode unreadable in the ruined parts of the support, where
software cannot always understand the code thus producing jittered or jerky
behavior.

In addition, turntable needles must follow tracks almost perfectly, or the
timecoded signal would degradate at the ADC side, especially the phase
component which is necessary for the purpose, but almost ignored in audio
players since the human ear has poor phase sensitivity.

Another bad point relates to the overall performance. It is true that with
this technique the performance is almost the same of a real vinyl, but the
need of an intermiate sound card, which in turn is often connected through the
USB bus, just makes low latencies hard to achieve, unless the host computer is
powerful and well optimised to reach soft-realtime requirements.

With a timecoded media is only possible to control the track position (phase)
and pitch (frequency), whihc is good for plain turntable emulation, but it is
impossible to use some features -- effects, precise loops, track preview, etc.
-- of some professional CD players.

When the disc spins at low speed, the intrinsic high-pass filter of needles
and soundcards will fade the signal, and it can become difficult to find the
zero-crossings while decoding. This issue makes slow scartches difficult to
emulate because of jitter and corruption, and will be mitigated with the work
devolped in the rest of this document.

Finally, a novice DJ would hardly choose this approach, because the overall
price of the equipment can be rather high -- turntables/players + good
soundcard + accurate needles + cables + hi-performance computer can easily
exceed \$3000. 


\paragraph{System architecture}
A common commercial architecture \cite{rane_ssl} \cite{ni_tsp} can be seen in
\citef{fig:serato_setup}. The existing turntables or CD players are connected
to the appropriate soundcard inputs.

The soundcard can be placed either inside or outside the host computer.
Internal soundcards are very fast in transfering data from the incoming audio
signal to the CPU, thanks to the fast system bus (PCI or PCI-E).

However, as internal soundacards are almost always designed for desktop
computers but notebook computers are much easier to carry, the choice of an
external soundcard is the very most common.

External soundcards are mostly connected through an USB bus, but some
professional FireWire soundcards are still on the market. The USB bus has the
drawback of having a fixed minimum latency of 1~ms for isochronous signals,
which increases latencies even more, while FireWire is faster -- good internal
soundcards have a negligible latency.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=0.9\columnwidth]{images/serato_setup.pdf}
	\caption{\emph{Serato Scratch Live} setup with two turntables}
	\label{fig:serato_setup}
\end{figurehere}


\paragraph{Signal pattern}
The timecoded signal is printed on the source media -- vinyl, CD -- with
patterns recognized by the specific user software. In general, the timecoded
signal is composed by a left sine and right cosine signals at a constant
frequency, usually in the range of 1~kHz to 3~kHz. The amplitude of each
half-wave of the same sign is slightly modulated with a proprietary digital
code, which represents the absolute position inside the whole timecoded track.

In \citef{fig:serato_timecode_slice} it is possible to see a slice of the
\emph{Serato Scratch Live} \cite{rane_ssl} timecode signal (aka
\emph{noisemap}), with some amplitude-modulated bits at the sine wave top
peaks.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/serato_timecode_slice.pdf}
	\caption{Slice of the \emph{Serato Scratch Live} timecode}
	\label{fig:serato_timecode_slice}
\end{figurehere}

To read the code from a timecoded stream, it is sufficient to trigger a
positive-slope zero-crossing on one channel, and read the amplitude on the
other channel (peak), then convert the amplitude into a bit of the code
word. If the absolute position is not needed, instead of the whole code it
is possible to interpret the sine/cosine simply as a quadrature control
signal, for relative motions.

The code is designed to be decoded in both directions, so that the user can
navigate the emulated turntable just like a real vinyl. The most advanced
codes are designed to support fast error correction, because dust, decay of
the vinyl, or even EMF, would generate a corrupted signal.

In fact, if a single code is a bare label of the position, for example of 20
bits, it is necessary to read at least 20 consecutive half-waves. With a
nominal frequency of 1~kHz, the minimum latency would become 20~ms, which is
rather high for audio manipulation by a human. Advanced codes would still
correctly read the first 20 half-waves, but then each subsequent bit is
sufficient to get the adjacent code, with only 1~ms delay at 1~kHz.

Some problems arise when the turntable is turning slowly. Due to the bandpass
behavior of the needle and active input/output stages of the whole signal
chain, slow transitions have a small amplitude. As it is well known in
communication technology field, slow and small transitions make zero-crossings
much harder to be tracked correctly, thus generating jitter or missing codes.
This is where optical motion sensors show their best performance instead.


\paragraph{Pros}
\begin{itemize*}
	\item Same old equipment
	\item Just add soundcard to a computer
	\item Natural feeling and performance
\end{itemize*}


\paragraph{Cons}
\begin{itemize*}
	\item Needs high quality components in the signal chain
	\item Expensive for a novice
	\item Signal subsceptible to corruption
	\item Bad tracking at low speeds
	\item Expensive signal processing
\end{itemize*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Optical motion sensors}
\label{sec:mouse_sensors}

Optical motion sensors are commonly found in computer pointing devices called
\emph{mouses}. The job of such sensors is to capture a \emph{photograph}
(i.e. a \emph{frame}) of what is beneath, compare it with the previous one,
and finally compute the motion (i.e. the distance) from the previous relative
position.

Their main strength is the achievement of very high resolution comparisons, in
the order of hundreds, if not thousands, \emph{Dots Per Inch} (\emph{DPI}), at
a very low price -- less than a dollar for average sensors, or a few dollars
for high performance (\emph{gaming}) mouse sensors. Also, the maximum
detectable speed is in the order of some tens inches per second, compatible
with human and motion.

As a drawback, the absolute accuracy is poor, as they are designed to capture
the slow relative movements of a screen cursor. It can be repositioned by
the software, or its relative motion is exploited for some games (e.g.
\emph{First Person Shooters}), thus making absolute motion tracking clueless.

As can be inferred from the previous statements, mouse sensors come in
different classes, based on their main applications. The most common sensors
are for office or home use, and provide average accuracy and speed. Other
sensors are designed for wireless devices, and can provide automatic switching
between average (or high) and low performance, based on the amount of
interaction of the user in the last time window. The most advanced sensors are
for those professionals or enthusiasts who need very high speed and precise
motion detection, for example for pro-gamers.


%-----------------------------------------------------------------------------
\subsection{Architecture and operation}

A generic mouse sensor is composed by components of various nature, as seen
in \citef{fig:sensor_assembly}.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,height=5cm]{images/sensor_assembly.pdf}
	\caption{Common motion sensor assembly}
	\label{fig:sensor_assembly}
\end{figurehere}


\paragraph{Light source}
A light source, typically a LED, or a laser for the most advanced models,
illuminates the small surface to be captured.


\paragraph{Lens}
A lens focuses the surface to get the best resolution at detector side.
The lens also increases the effectiveness of the light source on the surface,
when correctly focused on the surface beneath through a mirror.

Usually the lens is placed at a few millimiters from the surface, and
it is quite important to keep the nominal distance for the best perofrmance.


\paragraph{CCD}
The actual light sensor is a common \emph{Charge-Coupled Device}
(\emph{CCD}). It is designed to be very fast, to achieve a high frame rate.
It is also sensitive to a very small light spectrum, e.g. the infrared one,
so that environmental light noise is rejected, and image artifacts are acquired
better.

There are also some considerations based on the light type. LED-based devices
work well with all the bumpy surfaces, even the dark ones, but cannot work
on trasparent ones, where the reflection is very bad. They are suited for
everyday use.
Instead, laser-based give a way better tracking on all surfaces but the dark
ones. The tracking performance is suited for professionals.


\paragraph{DSP}
The frame impressed on the CCD is then processed by an \emph{ad-hoc}
\emph{DSP}, which computes the distance -- in $(x,y)$ frame coordinates --
from the previously acquired frame. The DSP must be fast enough to reach the
10x-in/s maximum detected velocity in both directions.


\paragraph{Controller}
Finally, the controller accumulates the DSP deltas. Some configuration
parameters and device properties, along with deltas, can be accessed through
an interface to an external controller.


%-----------------------------------------------------------------------------
\subsection{Communication}

Optical motion sensors communicate with an external processor through an
interface which often belongs to standard I/F types, even though some pins
are frequently added for faster or ad-hoc operation -- chip shutdown, chip
selection, flow control, and so on.


\paragraph{Quadrature}
Sensors with only quadrature wave outputs (see \citef{fig:quad_wave}) are now
outdated, because they do not offer any advanced features, and require an
interrupt-driven counter at controller side. On the other hand, quadrature
outputs can be used with any device which natively accepts such signals.


\paragraph{SSP}
When requiring some more flexibility, it is possible to adopt a
\emph{Synchronous Serial Port} in both \emph{Serial Peripheral Interface}
(\emph{SPI}) or \emph{3-wire}, respectively with full-duplex and half-duplex
capabilites, to communicate with motion sensors.

They usually do not require handshaking, even though some control pins are
often used in such a way (e.g. the common \emph{shutdown} pin). Also, the
bit rate is often high enough for simple and fast communication -- from
1~MHz to some tens.

Due to its message-based nature, it is possible not only to read internal
counters, but also to get and set configuration parameters of the target
device.

They can often support multi-master/multi-slave topologies, even though the
most common is single-master/multi-slave. Slaves are usually chosen by a
demultiplexed selection signal, one per slave.

An example of \emph{write} operation over a 3-wire SSP bus is shown in
\citef{fig:ssp_write}. The single master device signals to the single slave
an incoming \emph{write} operation, tells the register address and its value.

An example of \emph{read} operation over the same hardware is shown in
\citef{fig:ssp_read}. The master signals an incoming \emph{read} operation
and tells the address. After that, it lets the slave drive the SDIO line,
then eventually reads the addressed register value.

\begin{figure*}[t]
	\centering
	\includegraphics[keepaspectratio=true,height=1.8cm]{images/ssp_write.pdf}
	\caption{A typical write operation over a half-duplex, 3-wire SSP}
	\label{fig:ssp_write}
\end{figure*}

\begin{figure*}[t]
	\centering
	\includegraphics[keepaspectratio=true,height=1.8cm]{images/ssp_read.pdf}
	\caption{A typical read operation over a half-duplex, 3-wire SSP}
	\label{fig:ssp_read}
\end{figure*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Controller communication protocol comparison}
\label{sec:controller_protocols}

When developing a music-oriented controller, there is always a debate on which
communication standard is the most suitable for the application. The most
common standard are described in the following.


%-----------------------------------------------------------------------------
\subsection{Plain MIDI}

The truly \emph{de-facto} standard in music-oriented communication is the
\emph{Musical Instrument Digital Interface} (\emph{MIDI}). This was
developed in the '80s to be easy and cheap to manufacture, robust and rather
complete for standard music production, with some degree of freedom for
sub-protocols developed by manufacturers. It is still widely supported by
nowadays digital music equipment.

Common output and input circuits can be seen respectively in \citef{fig:midi_out}
and \citef{fig:midi_in}. Basically, it is a standard serial point-to-point
connection based on a common UART powered at TTL levels. Data transmitted by
the UART is converted into current bursts, which light the optocoupler at the
receiver. The optocoupler provides galvanic isolation, so that no
\emph{current loops} can create audible noise in the target device, which used
to be a synthesizer in the first place.

Each MIDI connection can handle up to 16 \emph{channels}, i.e. virtual music
devices. This is enough for common synthesizers, but not to drive an entire
production studio.

The event-based nature of the protocol makes it suitable for most of the
situations, but for events which could be accumulated, or state streaming.
For example, jogwheels could generate way too many motion delta events, usually
as Control Change messages, which would easily flood the entire bus. A packed
streaming state would be better suited in such cases.
Also, when transmitting to a host computer, its operating system (often
time-shared), software buffers can saturate while processing too many events
at a time, or complex sound textures.

The protocol does not support any kind of flow control. Massages can be lost,
partially received (ignored), contain errors, without being corrected or asked
for retransmission. Also, the relatively slow baud rate can generate small
delays between sound generation/control events, which can be detected by
the human brain, which is very sensitive to audio timing.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=0.6\columnwidth]{images/midi_out.pdf}
	\caption{MIDI output circuit, UART sends \emph{OUT} signal}
	\label{fig:midi_out}
\end{figurehere}

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/midi_in.pdf}
	\caption{MIDI input circuit, UART receives \emph{IN} signal}
	\label{fig:midi_in}
\end{figurehere}


\paragraph{Basic protocol}
The serial protocol is 8-bits per message word, with one start (low) and one
stop (high) bits, MSb first, 31250 baud. The protocol is message-driven, with
standard messages 3 bytes long. Special messages are 1 to 3 bytes long, while
manufacturer-defined \emph{System Exclusive} (\emph{SysEx}) messages can be
arbitrarily long. Most of the messages were associated to common synthesizer
features \cite{midi_messages}, even tough manufacturers often interpret them
freely (e.g. through \emph{remapping}).

The first word of a message (control word) is always identified by the MSb
set to 1, while it is always 0 for data words, which are always 7 bits wide.

Standard messages are those referred to the actual music content, such as
\emph{Note On/Off}, \emph{Control Change}, \emph{Pitch Change} and so on,
also called \emph{voice messages}. A timing diagram of a voice message is
shown in \citef{fig:midi_voice_msg}.

The control word identifies the message type and the channel number. The
second word is usually the identifier of the control (key, knob, slider,
wheel, etc.) being actioned, and the third word tells its value or velocity.

Special messages include transport control (time, position), program selection,
system messages, etc. These are advanced messages, often only partially
supported, if not at all, by cheap controllers.

\begin{figure*}[t]
	\centering
	\includegraphics[keepaspectratio=true,width=\textwidth]{images/midi_voice_msg.pdf}
	\caption{Timing diagram of a MIDI voice message}
	\label{fig:midi_voice_msg}
\end{figure*}


\paragraph{Pros}
\begin{itemize*}
	\item \emph{De-facto} standard for digital music equipment
	\item Intuitive message semantics
	\item Simple, robust, noise-free, cheap hardware
\end{itemize*}


\paragraph{Cons}
\begin{itemize*}
	\item Slow communication
	\item No flow control
	\item Low resolution controls
	\item No streaming state support
\end{itemize*}


%-----------------------------------------------------------------------------
\subsection{MIDI/USB}

The \emph{Universal Serial Bus} (\emph{USB}) \cite{usb_docs} is probabily the
most available for consumer electronics interfacing nowadays. Its multipurpose
nature, speed, and robustness, made it the \emph{de-facto} standard for
connecting an actual \emph{universe} of devices. Among this huge load of
devices, also the digital music related ones can be found.

Since the MIDI standard was the most common digital music standard at the time
USB was released, it was convenient to encapsulate it inside USB packets.
So, an \emph{application protocol} was developed over the USB protocol: the
\emph{MIDI over USB} (\emph{MIDI/USB}).

This way, compatibility with standard MIDI interfaces was kept. Production
software and hardware devices kept using it, an so did music production
people. USB is simply the low-level interface, which can be found on all
consumer computers.

MIDI/USB has some advantages over the plain MIDI protocol. Since USB has a
higher baud rate than MIDI, it is possible to reduce delays when handling
many messages in a short interval.

Also, MIDI/USB introduces the concept of \emph{cable}. It supports up to 16
cables, which are 16 virtual plain MIDI devices. This makes theoretically
possible to drive up to 16 hardware synthesizers through a single USB cable,
by dispatching the 16 virtual cables to as many real plain MIDI devices.

The MIDI/USB protocol exploits the features of \emph{bulk} transfers. This
way, packets will not be lost, thanks to the flow control of USB bulk
transfers.

USB devices can also show many indipendent behaviors, by choosing different
application protocols per each USB endpoint. For example, this allows to have
a MIDI/USB device with an integrated HID/USB trackpad,
by using a single USB cable, like the \emph{M-Audio Torq Xponent}
\cite{maudio_xponent}.

All the MIDI drawbacks are kept, except for the baud rate and flow control.
The USB, by its time-shared nature, always introduces some delays -- at
least 1~ms per query, and a few milliseconds for software stack processing.
As a drawback of bulk transfers, the delivering time is uncertain, because
many retansmissions can be issued, or there is not enough free bandwidth on
the bus, introducing even more delay.


\paragraph{Basic protocol}
The MIDI/USB protocol is a \emph{sub-class} of the \emph{Audio class}, defined
by the USB standard \cite{usb_docs}. This parent class is oriented to audio
equipment communication and control -- speakers, microphones, keyboards,
controllers, synthesizers, DSPs can all be driven by this class.

The packet is composed by a \emph{header byte}, and the remaining 3 bytes are
the encapsulated MIDI packet -- all but the SysEx messages, which have variable
length. The header byte addresses the cable, and defines the following MIDI
message type -- some bytes can be unused, and thus ignored by the USB parser.
SysEx messages are simply split into 3-bytes chunks, merged by the USB parser
when the trailing byte(s) are received.

The protocol supports \emph{bulk} USB transfers. They add flow control to bare
USB streams, which in order adds flow control to the encapsulated MIDI stream.
Bulk packets have the lowest priority over the USB bus, which could introduce
delays when the bus is saturated by \emph{interrupt} and \emph{isochronous}
endpoint transfers. Also, packet handshaking and retransmission may add
some delay too.


\paragraph{Pros}
\begin{itemize*}
	\item USB is \emph{de-facto} standard for consumer electronics
	\item Much higher bandwidth than plain MIDI
	\item Up to 16 virtual cables
	\item Multi-purpose device through a single USB cable
\end{itemize*}


\paragraph{Cons}
\begin{itemize*}
	\item All the MIDI drawbacks, except for baud rate and flow control
	\item Delays introduced by USB time-sharing and bulk transfers
\end{itemize*}


%-----------------------------------------------------------------------------
\subsection{HID/USB}

Besides MIDI/USB, another application protocol was developed to handle those
devices which interface with human beings, and is much widely implemented.
The \emph{Human Interface Device} (\emph{HID}), in fact, is an USB class
with huge flexibility and support -- it can be found in almost any USB device
with keys, knobs, sliders, simple displays, LEDs, control wheels and so on.

\TODO


\paragraph{Basic protocol}
\TODO


\paragraph{Pros}
\begin{itemize*}
	\item Highest USB priority
	\item State streaming
	\item \TODO
\end{itemize*}


\paragraph{Cons}
\begin{itemize*}
	\item Sill some USB delays
	\item Custom HID reports to parse
	\item \TODO
\end{itemize*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simplified proposed approach}
\label{sec:simplified_approach}

The proposed approach was developed so that it is possible to achieve good
performance both at high and low speeds, without introducing expensive parts.

The main idea is to use a mouse sensor to measure slow local motions, which
are difficult to process with timecode, and need high resolution jogwheels.
As seen in the previous section, this is not possible with cheap designs.

Slow local motions are common when scratching or trying to reposition the
virtual needle of the emulated turntable, for example when the DJ is searching
for a good point where to start playing from (\emph{cue} point).

When the disc is spinning at cruise speed, or when the rotation is fast
enough, the classic methods can be used to keep track of the position.
Mouse sensors, in fact, are not able to keep track of absolute movements,
especially when they are very fast. Anyway, even cheap sensors have a
resolution in the order of several hundreds, if not thousands, DPIs nowadays.

As proven later, the disc can theoretically be divided in thousands slices,
thus providing a local resolution higher than the most expensive encoders on
the market -- obviously in the set of those affordable for a DJ, not the
state-of-the-art encoders for hi-end industrial machineries.

In the following, a simplified prototype will be presented. A low-end MCU and
a standard COTS mouse sensor were chosen, just to see if it is possible to
achieve good performance with a simple circuit.


%-----------------------------------------------------------------------------
\subsection{Hardware architecture}

The simplified prototype has a very crude hardware architecture. It is split
into three modules: the \emph{controller board} (aka \emph{main board}), the
\emph{sensor board} and an optional \emph{timecode preamp board} for the use
with timecoded media. This subdivision was done just to decouple the
controller with the sensor, for further experiments with other hardware
configurations.


\paragraph{Controller board}
The controller board in \citef{fig:board_photo} hosts the MCU, a
\emph{PIC18LF14K50} \cite{microchip_pic18lf14k50} by \emph{Microchip}, which
is a 8-bits MCU running at 48~MHz (16 MIPS). It is fast enough to handle a
single wheel, but nothing more advanced such as DSP, which is left to the
user software application.

This board also mounts the voltage regulator, to get 3.3~V from the standard
5~V sourced by the USB host. Bulk capacitors keep it stable.

There are also a user button for input, and three LEDs for user interactions.

A standard UART can be used for basic messaging with an optional text console.

There are also two pins dedicated for an additional quadrature encoder input.
They can be configured to be directly coupled with the MCU comparator
interrupts, in order to trigger encoder changes.

To communicate with the sensor module some control and interrupt signals, and
a half-duplex serial port are provided.

The USB bus is directly connected to the MCU, which has an internal
\emph{Serial Interface Engine} configured for \emph{Full speed} transfers.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/board_photo.pdf}
	\caption{The controller prototype board}
	\label{fig:board_photo}
\end{figurehere}


\paragraph{Sensor board}
The sensor board in \citef{fig:sensor_photo} simply hosts the mouse sensor,
the surface illumination LED, and the lens. The sensor is an \emph{ADNS-2080}
\cite{avago_adns2080} by \emph{Avago}. It is a sensor aimed at office users,
with average performance and low cost. As for the MCU, higher performance
modules are on the market, but the challenge of this proposal was to find a
basic average solution, which can be improved with further research. Briefly,
the sensor can reach an interesting resolution of up to 2000~DPI, and motion
speed up to 30~in/s (76.2~cm/s). There is no guarantee of constant latencies,
because the clock speed is variable.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/sensor_photo.pdf}
	\caption{The optical motion sensor prototype board}
	\label{fig:sensor_photo}
\end{figurehere}


\paragraph{Timecode preamp board}
An optional board, seen in \citef{fig:preamp_photo}, was designed to properly
amplify a \emph{Line} -- no \emph{Phono}! -- timecode signal so that it can be
recognized by comparators of the controller board.

Each audio channel can be amplified in amplitude, by controlling the inverting
gain of the opamp with a potentiometer. A spare opamp generates the $V_{DD}/2$
voltage reference for single-supply conditioning.

Two LEDs help the user in keeping the overall timecode level compatible with
the comparator inputs on the controller board, by warning if the signal is
near saturation, or too low to be squared correctly by comparators.
In fact, when the volume is too low or saturates, the sinusoidal timecode
signals won't be squared with 50\% duty cycle, which can generate some jitter.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/preamp_photo.pdf}
	\caption{The timecode preamplifier prototype board}
	\label{fig:preamp_photo}
\end{figurehere}


%-----------------------------------------------------------------------------
\subsection{Firmware architecture}

Due to the lack of a \emph{Real-Time Operating System} (\emph{RTOS}) support
on the chosen MCU, the application was written in a \emph{while-loop} fashion,
with \emph{interrupt-driven} tasks at \emph{high priority}.


\paragraph{Bootloader}
In order to simplify firmware deployment, a HID bootloader was added to the
development prototype. This will occupy the first 2048 words of the program
space, which is not that small. The bootloader is the one provided by the
\emph{Microchip Application Libraries} \cite{microchip_mal}, and implements
HID control.

The bootloader can be called by plugging RATT into the USB host socket, while
pressing the user button. The developer can then use the HID bootloader
software provided by Microchip to download the complied HEX executable to the
program memory of the MCU.


\paragraph{HID/USB module}
The HID/USB module was devloped over the \emph{HID Simple Custom Demo}
provided with the \emph{Microchip Application Libraries} \cite{microchip_mal}.
The code itself is almost the same, so please refer to the documentation
delivered by Microchip for more information, as the topic is very complex and
cannot be described in a few words here.

RATT is a simple I/O HID device, which uses the endpoint 1 for both input and
output transfers. In the following, the descriptors used by HID/USB will be
described briefly.

\citet{tab:usb_device_desc} shows the \emph{Device} descriptor. It tells the
host it is a standard USB 2.0 device, with its vendor and product identifiers
(dummy in this case), with only one configuration. It also indicates there
are a manufacturer and product name strings to be received and indexed later.

\begin{tablehere}
\centering \scriptsize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1	& Number	& 18		\\
1	& bDescriptorType		& 1	& Constant	& 0x01		\\
2	& bcdUSB				& 2	& BCD		& 0x0200	\\
4	& bDeviceClass			& 1	& Class		& 0x00		\\
5	& bDeviceSubClass		& 1	& SubClass	& 0x00		\\
6	& bDeviceProtocol		& 1	& Protocol	& 0x00		\\
7	& bMaxPacketSize		& 1	& Number	& 8			\\
8	& idVendor				& 2	& ID		& 0xDEAD	\\
10	& idProduct				& 2	& ID		& 0xBEEF	\\
12	& bcdDevice				& 2	& BCD		& 0x0002	\\
14	& iManufacturer			& 1	& Index		& 1			\\
15	& iProduct				& 1	& Index		& 2			\\
16	& iSerialNumber			& 1	& Index		& 0			\\
17	& bNumConfigurations	& 1	& Integer	& 1			\\
\hline
\end{tabular}
\caption{USB Device descriptor}
\label{tab:usb_device_desc}
\end{tablehere}

The single \emph{Configuration} descriptor in \citet{tab:usb_config_desc}
tells the host that the device is powered by the USB bus at 100~mA maximum,
and there is only one interface for this configuration.

\begin{tablehere}
\centering \scriptsize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1	& Number	& 9				\\
1	& bDescriptorType		& 1	& Constant	& 0x02			\\
2	& wTotalLength			& 2	& Number	& 41			\\
4	& bNumInterfaces		& 1	& Number	& 1				\\
5	& bConfigurationValue	& 1	& Number	& 1				\\
6	& iConfiguration		& 1	& Index		& 0				\\
7	& bmAttributes			& 1	& Bitmap	& 0b11000000	\\
8	& bMaxPower				& 1	& mA/2		& 50			\\
\hline
\end{tabular}
\caption{USB Configuration descriptor}
\label{tab:usb_config_desc}
\end{tablehere}

The single \emph{Interface} descriptor in \citet{tab:usb_intf_desc} simply
indicates that it is a HID device. All the other options are ignored for this
device.

\begin{tablehere}
\centering \scriptsize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1	& Number	& 9			\\
1	& bDescriptorType		& 1	& Constant	& 0x04		\\
2	& bInterfaceNumber		& 1	& Number	& 0			\\
3	& bAlternateSetting		& 1	& Number	& 0			\\
4	& bNumEndpoints			& 1	& Number	& 2			\\
5	& bInterfaceClass		& 1	& Class		& 0x03		\\
6	& bInterfaceSubClass	& 1	& SubClass	& 0			\\
7	& bInterfaceProtocol	& 1	& Protocol	& 0			\\
8	& iInterface			& 1	& Index		& 0			\\
\hline
\end{tabular}
\caption{USB Interface descriptor}
\label{tab:usb_intf_desc}
\end{tablehere}

The \emph{HID Class-specific} descriptor in \citet{tab:hid_class_desc} is for
the HID 1.11 protocol, no country-specific address, with a single HID report
descriptor 48 bytes long.

\begin{tablehere}
\centering \scriptsize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1	& Number	& 9			\\
1	& bDescriptorType		& 1	& Constant	& 0x21		\\
2	& bcdHID				& 2	& BCD		& 0x0111	\\
4	& bCountryCode			& 1	& Number	& 0x00		\\
5	& bNumDescriptors		& 1	& Number	& 1			\\
6	& bDescriptorType		& 1	& Constant	& 0x22		\\
7	& wDescriptorLength		& 2	& Number	& 48		\\
\hline
\end{tabular}
\caption{HID Class-specific descriptor}
\label{tab:hid_class_desc}
\end{tablehere}

The USB \emph{Endpoint} descriptors in \citet{tab:usb_ep1i_desc} and
\citet{tab:usb_ep1i_desc} refer to the bidirectional endpoint 1, used to
handle HID transfers, polled each 1~ms with \emph{interrupt} scheduling.
Since the user needs very fast responses for very few data from the motion
sensor (16 bytes per report), these settings are optimal for the device
being developed.

\begin{tablehere}
\centering \scriptsize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1	& Number	& 7				\\
1	& bDescriptorType		& 1	& Constant	& 0x05			\\
2	& bEndpointAddress		& 1	& Number	& 0x81			\\
4	& bmAttributes			& 1	& Bitmap	& 0b00000011	\\
5	& wMaxPacketSize		& 2	& Number	& 16			\\
6	& bInterval				& 1	& ms		& 1				\\
\hline
\end{tabular}
\caption{USB IN Endpoint 1 descriptor}
\label{tab:usb_ep1i_desc}
\end{tablehere}

\begin{tablehere}
\centering \scriptsize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1	& Number	& 7				\\
1	& bDescriptorType		& 1	& Constant	& 0x05			\\
2	& bEndpointAddress		& 1	& Number	& 0x01			\\
4	& bmAttributes			& 1	& Bitmap	& 0b00000011	\\
5	& wMaxPacketSize		& 2	& Number	& 16			\\
6	& bInterval				& 1	& ms		& 1				\\
\hline
\end{tabular}
\caption{USB OUT Endpoint 1 descriptor}
\label{tab:usb_ep1o_desc}
\end{tablehere}

As told before, manufacturer and product names were indexed inside the Device
descriptor. The language code and those names, are shown in the \emph{String}
descriptors shown in \citet{tab:usb_lang_desc}, \citet{tab:usb_manuf_desc},
and \citet{tab:usb_prod_desc}.

\begin{tablehere}
\centering \scriptsize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1	& Number	& 4				\\
1	& bDescriptorType		& 1	& Constant	& 0x03			\\
2	& wString				& 2	& Unicode	& 0x0409		\\
\hline
\end{tabular}
\caption{USB Language Code string descriptor}
\label{tab:usb_lang_desc}
\end{tablehere}

\begin{tablehere}
\centering \scriptsize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1		& Number	& 12			\\
1	& bDescriptorType		& 1		& Constant	& 0x03			\\
2	& wString				& 10	& Unicode	& "TexZK"		\\
\hline
\end{tabular}
\caption{USB Manufacturer string descriptor}
\label{tab:usb_manuf_desc}
\end{tablehere}

\begin{tablehere}
\centering \scriptsize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1	& Number	& 10			\\
1	& bDescriptorType		& 1	& Constant	& 0x03			\\
2	& wString				& 8	& Unicode	& "RATT"		\\
\hline
\end{tabular}
\caption{USB Product string descriptor}
\label{tab:usb_prod_desc}
\end{tablehere}

Finally, the \emph{HID Report} descriptor in \citet{tab:hid_rpt_desc}
describes the syntax and semantics of the actual data being transferred by the
device application. Because of the custom semantics, the descriptor simply
indicates 16 bytes for both input and output transfers. Its semantics are
listed in \citef{fig:hid_rpt_struct}

\begin{tablehere}
\centering \scriptsize
\begin{tabular}{|rl|rl|}
\hline
\textbf{Field} & & \textbf{Value} &		\\
\hline
0x06	& Usage Page		& 0xFF00	& Vendor Defined Page 1		\\
0x09	& Usage				& 0x01		& Vendor Usage 1			\\
0xA1	& Collection		& 0x01		& Application				\\
\hline
0x19	& Usage Minimum		& 16		& 							\\
0x29	& Usage Maximum		& 16		&							\\
0x15	& Logical Minimum	& 0x00		&							\\
0x25	& Logical Maximum	& 0xFF		&							\\
0x75	& Report Size		& 8			& field bits				\\
0x95	& Report Count		& 16		& 							\\
0x81	& Input				& 0x00		& Data, Array, Abs			\\
0x19	& Usage Minimum		& 16		& 							\\
0x29	& Usage Maximum		& 16		&							\\
0x95	& Report Count		& 16		& 							\\
0x91	& Output			& 0x00		& Data, Array, Abs			\\
\hline
0xC0	& End Collection	&			&							\\
\hline
\end{tabular}
\caption{HID Report descriptor}
\label{tab:hid_rpt_desc}
\end{tablehere}

\begin{figurehere}
\begin{mdframed}[
	backgroundcolor=lightyellow,
	hidealllines=true,
	innerleftmargin=2pt,
	innerrightmargin=2pt
]
\begin{lstlisting}[
	language=C,
	basicstyle=\scriptsize\ttfamily,
	keywordstyle=\color{darkblue},
	identifierstyle=\color{darkred},
	commentstyle=\color{darkgreen}
]
typedef struct {
    unsigned long   timestamp;
    struct {
        signed short    dx;
        signed short    dy;
    }               sensorMotion;
    struct {
        unsigned short  x;
        unsigned short  y;
    }               sensorPos;
    signed short    incencMotion;
    unsigned short  incencPos;
} APP_HID_TX_REPORT;
\end{lstlisting}
\end{mdframed}
\caption{HID report semantics}
\label{fig:hid_rpt_struct}
\end{figurehere}



\paragraph{LED module}
The LED module simply drives the three LEDs on and off.


\paragraph{Encoder module}
A small software module (\emph{incenc}) decodes the quadrature signal fed by a
rotary encoder, or exploited from a properly timecoded media stream.

The quadrature encoder waves are gathered by the MCU by triggering interrupts
in a rather tricky way. The two quadrature inputs, namely \emph{A} and
\emph{B}, are connected to the negative inputs of the two comparators of the
chosen MCU. The comparators have an internal reference (positive input)
voltage fed by the internal DAC module at $V_{DD}/2$, with a small hysteresis.

Whenever the quadrature signal (A or B) crosses the reference voltage, an
high priority interrupt is generated. The ISR detects the current quadrature
phase and accumulates the single step into a global delta counter.

The delta counter can then be collected by the (slower) HID report generator,
which resets it.

The initialization routine simply configures the voltage reference DAC, the
two comparators, and interrupts.

There is no background service, since all the processing is triggered by
interrupt events.


\paragraph{Sensor module}
Another software module (\emph{adns2080}) handles the mouse sensor. This
module provides communication rountines over the SPI port of the MCU in a
half-duplex fashion.

All the communication routines are blocking, but this is not a problem because
they are executed in the background service (main loop) of the firmware
architecture.

An initialization routine configures the SPI port, then the mouse sensor. Its
setup will allow for top-performance (no low-power states), 12-bits deltas
reporting, and active-low level-sensitive motion interrupt generation.
This routine will also check for proper communication with the daughter board.

The high-priority motion interrupt is generated by the sensor whenever motion
is detected. This interrupt is cached by raising a firmware flag. The high
priority level will minimize CPU cycles for this very simply operation.

The background service polls for the interrupt flag, and starts a \emph{motion
burst} read, which collects motion deltas over the serial port by minimizing
dead times. Deltas are accumulated on global counters, which will be gathered
by the HID report generator and thuse reset.


\paragraph{Main module}
The main module, also called the \emph{app}, initializes the system, handles
the main loop, and provides some interrupt functions.

The initialization sequence calls the initialization of all the sub-modules.

The main loop cycles through the \emph{service task} of the sub-modules, so
that motion deltas are computed for both the sensor and incremental encoder
modules. If the deltas are meaningful and the HID transmission endpoint is
available, a new HID report is built and sent to the host.

The two interrupt handlers, one for high-priority and one for low-priority
interrupts, will obviously handle events generated by peripherals.

Some functions are dedicated to locking and unlocking of the application
resources, and are basically wrappers respectively to global interrupt disable
and enable.


\paragraph{Tasks organization}
The modules are organized in a \emph{while-loop} fashion, because the chosen
MCU has not enough computational power, nor a stack manageable by an actual
RTOS.

An initialization procedure will turn all the modules on, and enables
interrupts. After that, the main loop is entered.

Inside the main loop, incremental encoder and mouse sensor deltas are gathered
and, if the USB endpoint is free, sent by an HID report.

Fast and simple interrupt events are processed by the high-priority ISR, while
communication events, which are slower, are processed by the low-priority ISR.


\paragraph{Remarks}
\TODO


%-----------------------------------------------------------------------------
\subsection{Software architecture}

Thanks to the adoption of the HID standard, host software can communicate with
the device easily. In fact, all the major operating systems have full support
for the USB stack, including the HID application protocol.

The target software for RATT is a \emph{vinyl emulation software}. There is a
huge load of programs to emulate traditional DJ consoles, but not so many 
support HID controllers, and fewer let the user define his own mappings. Among
all of them, the reference software is \emph{Virtual~DJ} by \emph{Atomix
Productions} \cite{atomix_vdj}, available for both Microsoft Windows and Apple
MacOSX.


\paragraph{HID/USB connectivity}
Connection between Virtual~DJ and RATT is straightforward. This software has
native support for HID devices, which are \emph{plug and play} and
\emph{hot-pluggable}.

After connection, Virtual~DJ searches for a valid mapping for the device. If
found, it is immediately loaded, otherwise the invalid device is simply
ignored.


\paragraph{Device description}
In order to be considered, a device must supply the device definition to
Virtual~DJ, in this case for a HID device \cite{vdj_hiddef} as seen in
\citef{fig:vdj_device_def}. The VID and PID are the actual HID device
identifier, and the HID report size is specified. The device supports only one
deck at a time.

The device description is divided in four pages. The \emph{init} and
\emph{exit} pages should contain information for both initialization and
deinitialization respectively, and are ignored. The \emph{out} page is ignored
too, because the device does not receive any meaningful messages from the
host software.

Instead, the \emph{in} page contains the description of the three motion
sources. They are all interpreted as jogwheels, with full 16-bit unsigned
counters which keep track of the accumulated position. The \emph{full}
attribute tells the jogwheel CPR, and needs to be calibrated with geometrical
parameters of the wheel itself.

On Windows, the XML text must be saved in:\\
{\ttfamily\small {\%}UserProfile{\%}/Documents/VirtualDJ/Devices/}
while on MacOSX in:\\
{\ttfamily\small {\textasciitilde}/Documents/VirtualDJ/Devices/}\\
for example as {\ttfamily\small ratt{\_}device.xml}.

\begin{figurehere}
\begin{mdframed}[
	backgroundcolor=lightyellow,
	hidealllines=true,
	innerleftmargin=4pt,
	innerrightmargin=4pt
]
\begin{lstlisting}[language=simpleXML]
<?xml version="1.0" encoding="UTF-8"?>
<device name="RATT" author="TexZK" decks="1"
 type="HID" vid="0xDEAD" pid="0xBEEF"
 reportsize="16" date="10/08/2012">
  <page type="init">
    <!-- Nothing to initialize -->
  </page>
  <page type="in">
    <!-- Optical motion sensor X position -->
    <jog name="SENSOR_POS_X"
     byte="8" size="word" endian="little"
     full="24000" min="0" max="65535"/>
    <!-- Optical motion sensor Y position -->
    <jog name="SENSOR_POS_Y"
     byte="10" size="word" endian="little"
     full="24000" min="0" max="65535"/>
    <!-- Quadrature encoder input -->
    <jog name="QUAD_POS"
     byte="14" size="word" endian="little"
     full="4000" min="0" max="65535"/>
  </page>
  <page type="out">
    <!-- No outputs -->
  </page>
  <page type="exit">
    <!-- Nothing to deinitialize -->
  </page>
</device>
\end{lstlisting}
\end{mdframed}
\caption{Virtual~DJ device definition for RATT}
\label{fig:vdj_device_def}
\end{figurehere}


\paragraph{Device mapping}
Once the device is recognized by Virtual~DJ, it needs to be \emph{mapped}
\cite{vdj_mapping}. The mapping process associates a control event, declared
by the device definition, to some actions. These actions are executed by
parsing the \emph{VDJscript} syntax \cite{vdj_script}.

For demonstration purposes, only the optical motion sensor X position will be
processed as jogwheel position by the software, while the Y position and the
quadrature position will be ignored.

The XML text in \citef{fig:vdj_device_map} summarizes the actions being
mapped. On Windows, it must be saved in:\\
{\ttfamily\small {\%}UserProfile{\%}/Documents/VirtualDJ/Mappers/}
while on MacOSX in:\\
{\ttfamily\small {\textasciitilde}/Documents/VirtualDJ/Mappers/}\\
for example as {\ttfamily\small ratt{\_}mapping.xml}.

\begin{figurehere}
\begin{mdframed}[
	backgroundcolor=lightyellow,
	hidealllines=true,
	innerleftmargin=4pt,
	innerrightmargin=4pt
]
\begin{lstlisting}[language=simpleXML]
<?xml version="1.0" encoding="UTF-8"?>
<mapper device="RATT" author="TexZK"
 description="RATT" version="704" date="10/08/2012">
  <!-- Use the sensor X position as a jogwheel -->
  <map value="SENSOR_POS_X" action="jogwheel"/>
  <!-- Ignore the sensor Y position -->
  <map value="SENSOR_POS_Y" action="nothing"/>
  <!-- Ignore the quadrature input -->
  <map value="QUAD_POS" action="nothing"/>
</mapper>
\end{lstlisting}
\end{mdframed}
\caption{Virtual~DJ device mapping for RATT}
\label{fig:vdj_device_map}
\end{figurehere}


%-----------------------------------------------------------------------------
\subsection{Sizing and computations}

\TODO


%-----------------------------------------------------------------------------
\subsection{Field results}

\TODO


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Advanced proposed approach}
\label{sec:advanced_approach}

Due to the few capabilities of the simplified approach, which is just for
basic research and demonstration purposes, a more advanced way to achieve
better results is presented in the following. No prototype was made, but a
high-level description of the target architecture can drive the development
of an actual device.

Basically, the advanced approach exploits the computational power of the most
recent MCUs, in order to provide faster motion detection and processing rate,
as well as the opportunity to handle tasks outside those for the motion
detection.

\TODO


%-----------------------------------------------------------------------------
\subsection{Hardware architecture}

The generic architecture reflects that of complex digital DJ controllers
which offer jogwheels (often touch-sensitive), but also buttons, knobs,
sliders, lights, displays, external connections, audio piping to DSP, and so
on.

By choosing a fully-featured MCU of nowadays, such as the \emph{STM32~F4}
series \cite{st_stm32f4}, it is possible to handle almost all these devices
with only one MCU, at reduced overall price. Obviously, some additional chips
are still needed -- motion sensors \emph{in primis} -- but the whole
architecture can be shrunk into a few chips.


\paragraph{Digital inputs}
The most basic type of inputs is \emph{discrete-state} (\emph{digital)} input
devices, such as buttons, switches, toggles, and so on. In order to handle
them, a \emph{matrix} topology often suffices, such as the one seen in
\citef{fig:keypad}. Such matrix can be scanned row-by-row, active low logic,
with full support for multiple elements active at the same time.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=0.8\columnwidth]{images/keypad.pdf}
	\caption{$ 3 \times 3 $ keypad, active low, multiple key presses}
	\label{fig:keypad}
\end{figurehere}


\paragraph{Analog inputs}
The user should also be able to control DJ software parameters with a 
continuous values range. Such values are provided through knobs and sliders.
Electrically, these devices are all potentiometers connected to the ADC module
of the MCU through its analog multiplexer, as shown in \citef{fig:pots_mcu}.
The analog values will then be converted by the ADC and processed by the
\emph{analog inputs task} of the firmware.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/pots_mcu.pdf}
	\caption{4 potentiometers connected to a MCU, through its built-in analog
	multiplexer and ADC}
	\label{fig:pots_mcu}
\end{figurehere}


\paragraph{Jogwheels}
Jogwheels are fundamentally those developed in the simplified approach at
Section~\ref{sec:simplified_approach}. Each jogwheel is made by a
medium-resolution optical quadrature wheel and its encoder, plus an optical
motion sensor.

The quadrature encoder, thanks to its fairly low speed, can be handled by
MCU interrupt signals (edge-triggered, both signs).

Instead, motion sensors must be connected to the appropriate digital bus
(I2C, SSP, SPI), and additional pins to suitable inputs.

Jogwheels should also provide touch-sensitivity, so that a digital signal
(see above) can be generated when the user puts fingers on the wheel.
There are different ways to provide touch sensitivity, but will not be
covered in this document.


\paragraph{Lights}
Some light can help the user in keeping track of some DJ software states.
Thanks to their very low current consumption and simplicity, LEDs are
always the best choice.

Simple lights can be driven directly by the MCU digital pins, in
any desirable fashion -- could it be direct coupling, LED matrix,
or charlieplexing. These lights can be either on or off.

Dimmed lights are more complex to handle, and need to be connected to PWM
outputs to give an intensity effect to the human eye, proportional to the
PWM duty cycle. Due to scarcity of such outputs, this feature is often not
implemented at all, or applied to simple behaviors -- for example, the
\emph{M-Audio Torq Xponent} \cite{maudio_xponent} gives the so-called
\emph{Christmas tree} effect, with all LEDs beign modulated by the music tempo.


\paragraph{Displays}
Very advanced controllers sometimes provide information through one or more
displays. There are so many display types on the market, that it is difficult
to suggest one. Anyway, for pure text displays, or generally soft-realtime
information visualization, the connection to one among the common UART, I2C,
SPI buses is enough.


%-----------------------------------------------------------------------------
\subsection{Firmware architecture}

\TODO


\paragraph{Main module}
\TODO


\paragraph{HID/USB module}
\TODO


\paragraph{LED module}
\TODO


\paragraph{Encoder module}
\TODO


\paragraph{Sensor module}
\TODO


\paragraph{Debug module}
\TODO


\paragraph{Tasks organization}
\TODO


\paragraph{Remarks}
\TODO


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Conclusions}
\label{sec:conclusions}

\TODO


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{splncs}
\bibliography{Report}

\end{multicols}
\end{document}
