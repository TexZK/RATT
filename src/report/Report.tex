% VDE Template for EUSAR Papers
% Provided by Barbara Lang und Siegmar Lampe
% University of Bremen, January 2002
% English version by Jens Fischer
% German Aerospace Center (DLR), December 2005
% Additional modifications by Matthias Wei{\ss}
% FGAN, January 2009

%-----------------------------------------------------------------------------
% Type of publication
\documentclass[a4paper,10pt]{article}
%-----------------------------------------------------------------------------
% Other packets: Most packets may be downloaded from www.dante.de and
% "tcilatex.tex" can be found at (December 2005):
% http://www.mackichan.com/techtalk/v30/UsingFloat.htm
% Not all packets are necessarily needed:
\usepackage{lmodern}
\usepackage{textcomp}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
%\usepackage{ngerman} % in german language if required
\usepackage{hyperref}
\usepackage[nooneline,bf,hypcap,font=small]{caption} % Figure descriptions from left margin
\usepackage{times}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{epstopdf}
\usepackage{mdwlist}
\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{listings}
\usepackage{mdframed}
\usepackage{inconsolata}
\usepackage[greek,english]{babel}
\input{tcilatex}
%-----------------------------------------------------------------------------
% Page Setup
\textheight24cm \textwidth17cm \columnsep6mm
\oddsidemargin-5mm                 % depending on print drivers!
\evensidemargin-5mm                % required margin size: 2cm
\headheight0cm \headsep0cm \topmargin0cm \parindent0cm
\pagestyle{empty}                  % delete footer and header
%-----------------------------------------------------------------------------
% Environment definitions
\newenvironment*{mytitle}{\begin{LARGE}\bf}{\end{LARGE}\\}%
\newenvironment*{mysubtitle}{\bf}{\\[1.5ex]}%
\newenvironment*{myabstract}{\begin{Large}\bf}{\end{Large}\\[2.5ex]}%
%-----------------------------------------------------------------------------
% Using Pictures and tables:
% - Instead "table" write "tablehere" without parameters
% - Instead "figure" write "figurehere " without parameters
% - Please insert a blank line before and after \begin{figuerhere} ... \end{figurehere}
%
% CAUTION:   The first reference to a figure/table in the text should be formatted fat.
%
%\begin{figurehere}
%  \centering
%  \includegraphics[width=8cm, height=4cm]{./eps/placeholder.eps}
%  \caption{Some single-column figure caption.}
%  \label{fig:myfigure1}
%\end{figurehere}
%
%\begin{figure*}[t]
%  \centering
%  \includegraphics[width=16cm, height=4cm]{./eps/placeholder.eps}
%  \caption{Some wide-figure caption.}
%  \label{fig:myfigure2}
%\end{figure*}

\makeatletter
\newenvironment{tablehere}{\def\@captype{table}\vspace{2ex}}{\vspace{2ex}}
\newenvironment{figurehere}{\def\@captype{figure}\vspace{2ex}}{\vspace{2ex}}
\makeatother

\newcommand{\TODO}{\textbf{TODO\dots\ }}
\newcommand{\CITEME}{\textbf{[CITEME]}}
\newcommand{\INSFIG}{\textbf{Figure PLACEHOLDER}}
\renewcommand{\thefigure}{\arabic{figure}}
\newcommand{\citef}[1]{\textbf{Figure~\ref{#1}}}
\newcommand{\citet}[1]{\textbf{Table~\ref{#1}}}

\definecolor{darkred}{rgb}{0.5,0.0,0.0}
\definecolor{darkgreen}{rgb}{0.0,0.5,0.0}
\definecolor{darkblue}{rgb}{0.0,0.0,0.5}
\definecolor{lightyellow}{rgb}{1.0,1.0,0.9}

\lstdefinelanguage{simpleXML}
{
	tabsize=2,
	breaklines=true,
	basicstyle=\scriptsize\ttfamily\color{darkblue},
	keywordstyle=\color{blue},
	stringstyle=\color{darkred},
	commentstyle=\color{darkgreen},
	showstringspaces=false,	
	morestring=[b]",
	morecomment=[s]{<!--}{-->},
	morecomment=[s]{<?}{?>},
	morekeywords={}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

% Computation results
\newcommand{\ttDiscDiam}{12.00}
\newcommand{\ttNomAngSpeed}{33.00}
\newcommand{\ttPitchOff}{0.00}
\newcommand{\ttDiscPerim}{37.70}
\newcommand{\ttAngSpeed}{33.00}
\newcommand{\ttRevRate}{0.550}
\newcommand{\ttRevTime}{1.818}
\newcommand{\ttTgSpeed}{20.73}
		
\newcommand{\ssRes}{2000}
\newcommand{\ssMaxSpeed}{30}
\newcommand{\ssMaxDotRate}{60000}
\newcommand{\ssMaxDotsOneMs}{60}
		
\newcommand{\mmRadius}{4.00}
\newcommand{\mmAngleOff}{0.00}
\newcommand{\mmRadiusCm}{10.16}
\newcommand{\mmPerim}{25.13}
\newcommand{\mmSpeed}{13.82}
\newcommand{\mmDotRate}{27646}
\newcommand{\mmRevDots}{50265}



\begin{mytitle}RATT	- Relatively Accurate TurnTable\end{mytitle}
\begin{mysubtitle}Relative turntable motion detection through mouse sensors\end{mysubtitle}
% Please do not insert a line here
\\
Zoppi Andrea\\
Matr. 765662, (andrea.zoppi@mail.polimi.it)\\
\begin{flushright}
\emph{Report for the master course of Embedded Systems}\\
\emph{Reviser: PhD. Patrick Bellasi (bellasi@elet.polimi.it)}
\end{flushright}

Received: <MONTH>, <DAY> 2012\\
\hspace{10ex}

\begin{myabstract} Abstract \end{myabstract}
Cheap jogwheel encoders for emulated DJ turntables are often inaccurate, due
to the low CPR in the order of some tens. Precise encoders are rather expensive
and are not convenient to keep track of very fast rotations, because they
are too much accurate for the purpose.

The presented research tries to improve the detection of at least small and
slow relative rotations of the jogwheel, by employing a cheap COTS mouse sensor,
and keep the absolute position or fast rotation with the classic cheap optical
encoder.

A very crude HID demoboard was developed, so that some simple tests were done.
An extended proposal is also described, in order to achieve better performance
and more features, to match those of a commercial DJ controller.


\vspace{4ex}	% Please do not remove or reduce this space here.
\begin{multicols}{2}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{sec:introduction}

In the latest years, the market of digital-DJ related products has grown
considerably. By the way, cheap digital turntable emulation is still tricky,
because the design of a cheap yet accurate jogwheel is still a challenge even
with the technology available today.

It is true that state-of-the-art processing units are very fast, but there are
still issues such as those related to protocol latency, precise and fast plate
motion detection, motion samples interpolation, and so on.

These issues are not a big problem for the average DJ, but they arise when
requiring a higher performance (e.g. \emph{scratch}) while keeping the costs
low.

The proposed approach is based on COTS components called \emph{optical motion/mouse
sensors}, which can provide a very good accuracy when detecting small local
motions, which is a behavior difficult to obtain with cheap encoders.

A simplified verison of the proposal was developed on a crude prototype, just
to check if it is worth at least for the average DJ -- the most demanding ones
do not care about the price of products, and still rely on timecoded vinyl
emulation even tough high CPR optical encoders are available at the same
overall price.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Current market}
\label{sec:current_market}

The common commercial approaches can be divided into two groups: jogwheels
based on optical encoders, and reuse of vinyl turntables (or CD players) as if
they were digital jogwheels. These two technologies will be described in the
following, showing their pros and cons.

There exist also some other ways to emulate turntables, which are currently
still in a niche. For example, there are some touchscreen-based \cite{sm_emulator}
\cite{hn_touchosc} or capacitive \cite{stanton_scs3d} controllers, which
follow the market wave of touchscreen devices.

There are also some evolutions of the optical jogwheels, which are motorized
\cite{denon_sc3900} \cite{numark_v7} and thus more suitable for professionals,
but rather expensive.


%-----------------------------------------------------------------------------
\subsection{Optical encoder jogwheel controllers}

The most common technology for turntable emulation is based on optical encoders.
An optical encoder is a device which detects motion by counting the number of
steps an evenly-marked wheel performs. It is found in almost all purely digital
DJ \emph{controllers}, which in this context are referred to those remote
digital devices used by the DJ to control the user application. Some examples
of commercial controllers with jogwheels can be found in \cite{eks_op}
\cite{pioneer_ddjs1} \cite{vestax_vci400}.

Common jogwheels have a resolution (\emph{CPR, Counts Per Revolution}) in the
order of tens, thus are not suitable for \emph{scratching}, and are usually
addressed only in coarse track navigation, or \emph{bending}.
Even a resolution in the order of some hundreds cannot be enough for scratch
or precise motion tracking. For example, with a 720 CPR encoder it is possible
to detect only motions of half degrees, that for a 12 inches wide wheel is
still low -- keep in mind that a vinyl spins at roughly 150 degrees per second,
and good sampling should require at least 1500 samples per second to track it
decently enough at nominal speed.


\paragraph{System architecture}
The basic architecture of these controllers is shown is \citef{fig:hercules_mp3e2_schematic}.
The controller commonly has a set of input devices -- buttons, knobs,
sliders, \emph{etc.} -- so that the user can \emph{map} these inputs to some
software actions, such as the play/stop events, or the desired volume level.

A special kind of input device focused throughout this work is the optical
encoder, which will be described in depth later.

Commonly, there is a also set of output devices -- LEDs, displays -- so that
the user's sight should not always keep switching switched between the computer
monitor and the controller to see what is going on.

All these devices are managed by a MCU, which detects their changes, and
generates meaningful messages to be sent to the DJ software, or receives
messages from the latter.

The communication between the controller and the software is often performed
through an USB bus with HID/USB or MIDI/USB protocols, but some controllers
still rely on the plain old MIDI port (see Section~\ref{sec:controller_protocols}).

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/hercules_mp3e2_schematic.png}
	\caption{\emph{Hercules DJ Control MP3 e2} \cite{hercules_djcmp3e2}
	intereface schematic with \textcolor{cyan}{buttons}, \textcolor{red}{incremental encoders},
	\textcolor{green}{sliders and knobs}}
	\label{fig:hercules_mp3e2_schematic}
\end{figurehere}


\paragraph{Wheel architecture}
The wheel is emulated with a so-called \emph{jogwheel}. It is a disc whose
full rotation is divided into equally-spaced angle slices. Each slice is
assigned a code.

Usually, the code is marked on the wheel with holes aligned on circles (see
\citef{fig:encoder_wheels}), so that holes can be detected by light detectors
mounted on the chassis. The light detector is almost always made with a LED
which points towards the disc, and on the other side the light is detected by
a fast phototransistor. These light sensors are positioned so that they can
detect one and only one code per slice.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=0.9\columnwidth]{images/encoder_wheels.jpg}
	\caption{A set of incremental (quadrature) rotary encoder wheels}
	\label{fig:encoder_wheels}
\end{figurehere}

The code is either abolute or relative. Absolute encoders assign a unique code
to each slice, so that it is always possible to know the current wheel angle
by just reading the light detector outputs. Due to the need to have a high
number of bits, the number of holes can also grow exponentially (usually as
the power of two), and the production of precisely aligned marks and sensors
is expensive -- misaligned ones can provide misdetections of the angle, even
with robust codes such as the \emph{Gray code}.

Instead, relative encoders just need the two least significant bits of an
absolute code, thus cheaper to manufacture. On the other hand, it is not
possible to know the absolute rotation without any additional bits. This is
why there is often a mark which signals a full revolution been performed, and
needs an additional flag bit. The particular subset of the Grey code used for
the relative motion detection is called \emph{quadrature code}, because only 4
code sequences (phases) can be generated by moving to the adjacent wheel slice
as seen in \citef{fig:quad_wave}.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=0.9\columnwidth]{images/quad_wave.pdf}
	\caption{Quadrature pattern, going forward left-to-right}
	\label{fig:quad_wave}
\end{figurehere}

An example of jogwheel internals can be seen in \citef{fig:vestax_vci400_jogwheel}.
It is a close-up of the \emph{Vestax VCI-400} \cite{vestax_vci400} jogwheel
architecture, with a high-resolution wheel -- segments can be barely seen --
and an \emph{Agilent HEDS-9700} quadrature encoder.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=0.8\columnwidth]{images/vestax_vci400_jogwheel.jpg}
	\caption{A \emph{Vestax VCI-400} jogwheel being disassembled}
	\label{fig:vestax_vci400_jogwheel}
\end{figurehere}


\paragraph{Motion detection}
When the user turns the wheel, the light detectors can convert the sight of
light into the code assigned to the focused disc slice. The digital code is
then triggered by the MCU through some interrupts, and a message containing
the motion (or even the absolute angle) is sent to the user software.


\paragraph{Pros}
\begin{itemize*}
	\item Easy to manufacture
	\item Code detection is inherently digital
	\item Fast code transitions can be processed easily
	\item A cheap MCU can handle jogwheels as well as all the other digital
		devices commonly found in DJ controllers
\end{itemize*}


\paragraph{Cons}
\begin{itemize*}
	\item Small motions have poor resolution with cheap encoders
	\item High resolution encoders are too much expensive for the purpose
\end{itemize*}


%-----------------------------------------------------------------------------
\subsection{Timecoded media turntable emulation}

An alternative way to emulate a turntable in software is to use a
\emph{timecoded audio track}, which is an audio stream coded so that the
software can read the track position just by decoding the incoming audio
stream.

This technique makes it possible to use existing turntables or CD players to
control the user software, which in turn will emulate the turntable behavior.

The good side of this approach is that a DJ, who already owns turntables or CD
players, can keep using them just by buying a sound card with the appropriate
audio inputs. This way the DJ can have almost perfectly the same old feeling,
because he is still using the same equipment.

On the bad side, vinyls and CDs are very sensible to usage, and decay easily.
This makes the timecode unreadable in the ruined parts of the support, where
software cannot always understand the code thus producing jittered or jerky
behavior.

In addition, turntable needles must follow tracks almost perfectly, or the
timecoded signal would degradate at the ADC side, especially the phase
component which is necessary for the purpose, but almost ignored in audio
players since the human ear has poor phase sensitivity.

Another bad point relates to the overall performance. It is true that with
this technique the performance is almost the same of a real vinyl, but the
need of an intermiate sound card, which in turn is often connected through the
USB bus, just makes low latencies hard to achieve, unless the host computer is
powerful and well optimised to reach soft-realtime requirements.

With a timecoded media is only possible to control the track position (phase)
and pitch (frequency), whihc is good for plain turntable emulation, but it is
impossible to use some features -- effects, precise loops, track preview, etc.
-- of some professional CD players.

When the disc spins at low speed, the intrinsic high-pass filter of needles
and soundcards will fade the signal, and it can become difficult to find the
zero-crossings while decoding. This issue makes slow scartches difficult to
emulate because of jitter and corruption, and will be mitigated with the work
devolped in the rest of this document.

Finally, a novice DJ would hardly choose this approach, because the overall
price of the equipment can be rather high -- turntables/players + good
soundcard + accurate needles + cables + hi-performance computer can easily
exceed \$3000. 


\paragraph{System architecture}
A common commercial architecture \cite{rane_ssl} \cite{ni_tsp} can be seen in
\citef{fig:serato_setup}. The existing turntables or CD players are connected
to the appropriate soundcard inputs.

The soundcard can be placed either inside or outside the host computer.
Internal soundcards are very fast in transfering data from the incoming audio
signal to the CPU, thanks to the fast system bus (PCI or PCI-E).

However, as internal soundacards are almost always designed for desktop
computers, while notebook computers are much easier to carry, the choice of an
external soundcard is the very most common.

External soundcards are mostly connected through an USB bus, but some
professional FireWire soundcards are still on the market. The USB bus has the
drawback of having a fixed minimum latency of 1~ms for isochronous signals,
which increases latencies even more, while FireWire is faster -- good internal
soundcards have a negligible latency.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=0.9\columnwidth]{images/serato_setup.pdf}
	\caption{\emph{Serato Scratch Live} setup with two turntables}
	\label{fig:serato_setup}
\end{figurehere}


\paragraph{Signal pattern}
The timecoded signal is printed on the source media -- vinyl, CD -- with
patterns recognized by the specific user software. In general, the timecoded
signal is composed by a left sine and right cosine signals at a constant
frequency, usually in the range of 1~kHz to 3~kHz. The amplitude of each
half-wave of the same sign is slightly modulated with a proprietary digital
code, which represents the absolute position inside the whole timecoded track.

In \citef{fig:serato_timecode_slice} it is possible to see a slice of the
\emph{Serato Scratch Live} \cite{rane_ssl} timecode signal (aka
\emph{noisemap}), with some amplitude-modulated bits at the sine wave top
peaks.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/serato_timecode_slice.pdf}
	\caption{Slice of the \emph{Serato Scratch Live} timecode}
	\label{fig:serato_timecode_slice}
\end{figurehere}

To read the code from a timecoded stream, it is sufficient to trigger a
positive-slope zero-crossing on one channel, and read the amplitude on the
other channel (peak), then convert the amplitude into a bit of the code
word. If the absolute position is not needed, instead of the whole code it
is possible to interpret the sine/cosine simply as a quadrature control
signal, for relative motions.

The code is designed to be decoded in both directions, so that the user can
navigate the emulated turntable just like a real vinyl. The most advanced
codes are designed to support fast error correction, because dust, decay of
the vinyl, or even EMF, would generate a corrupted signal.

In fact, if a single code is a bare label of the position, for example of 20
bits, it is necessary to read at least 20 consecutive half-waves. With a
nominal frequency of 1~kHz, the minimum latency would become 20~ms, which is
rather high for audio manipulation by a human. Advanced codes would still
correctly read the first 20 half-waves, but then each subsequent bit is
sufficient to get the adjacent code, with only 1~ms delay at 1~kHz.

Some problems arise when the turntable is turning slowly. Due to the bandpass
behavior of the needle and active input/output stages of the whole signal
chain, slow transitions have a small amplitude. As it is well known in
communication technology field, slow and small transitions make zero-crossings
much harder to be tracked correctly, thus generating jitter or missing codes.
This is where optical motion sensors show their best performance instead.


\paragraph{Pros}
\begin{itemize*}
	\item Same old equipment
	\item Just add soundcard to a computer
	\item Natural feeling and performance
\end{itemize*}


\paragraph{Cons}
\begin{itemize*}
	\item Needs high quality components in the signal chain
	\item Expensive for a novice
	\item Signal subsceptible to corruption
	\item Bad tracking at low speeds
	\item Expensive signal processing
\end{itemize*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Optical motion sensors}
\label{sec:mouse_sensors}

Optical motion sensors are commonly found in computer pointing devices called
\emph{mouses}. The job of such sensors is to capture a \emph{photograph}
(i.e. a \emph{frame}) of what is beneath, compare it with the previous one,
and finally compute the motion (i.e. the distance) from the previous relative
position.

Their main strength is the achievement of very high resolution comparisons, in
the order of hundreds, if not thousands, \emph{Dots Per Inch} (\emph{DPI}), at
a very low price -- less than a dollar for average sensors, or a few dollars
for high performance (\emph{gaming}) mouse sensors. Also, the maximum
detectable speed is in the order of some tens inches per second, compatible
with human and motion.

As a drawback, the absolute accuracy is poor, as they are designed to capture
the slow relative movements of a screen cursor. It can be repositioned by
the software, or its relative motion is exploited for some games (e.g.
\emph{First Person Shooters}), thus making absolute motion tracking clueless.

As can be inferred from the previous statements, mouse sensors come in
different classes, based on their main applications. The most common sensors
are for office or home use, and provide average accuracy and speed. Other
sensors are designed for wireless devices, and can provide automatic switching
between average (or high) and low performance, based on the amount of
interaction of the user in the last time window. The most advanced sensors are
for those professionals or enthusiasts who need very high speed and precise
motion detection, for example for pro-gamers.


%-----------------------------------------------------------------------------
\subsection{Architecture and operation}

A generic mouse sensor is composed by components of various nature, as seen
in \citef{fig:sensor_assembly}.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,height=4cm]{images/sensor_assembly.pdf}
	\caption{Common motion sensor assembly}
	\label{fig:sensor_assembly}
\end{figurehere}


\paragraph{Light source}
A light source, typically a LED, or a laser for the most advanced models,
illuminates the small surface to be captured.


\paragraph{Lens}
A lens focuses the surface to get the best resolution at detector side.
The lens also increases the effectiveness of the light source on the surface,
when correctly focused on the surface beneath through a mirror.

Usually the lens is placed at a few millimiters from the surface, and
it is quite important to keep the nominal distance for the best perofrmance.


\paragraph{CCD}
The actual light sensor is a common \emph{Charge-Coupled Device}
(\emph{CCD}). It is designed to be very fast, to achieve a high frame rate.
It is also sensitive to a very small light spectrum, e.g. the infrared one,
so that environmental light noise is rejected, and image artifacts are acquired
better.

There are also some considerations based on the light type. LED-based devices
work well with all the bumpy surfaces, even the dark ones, but cannot work
on trasparent ones, where the reflection is very bad. They are suited for
everyday use.
Instead, laser-based give a way better tracking on all surfaces but the dark
ones. The tracking performance is suited for professionals.


\paragraph{DSP}
The frame impressed on the CCD is then processed by an \emph{ad-hoc}
\emph{DSP}, which computes the distance -- in $(x,y)$ frame coordinates --
from the previously acquired frame. The DSP must be fast enough to reach the
10x-in/s maximum detected velocity in both directions.


\paragraph{Controller}
Finally, the controller accumulates the DSP deltas. Some configuration
parameters and device properties, along with deltas, can be accessed through
an interface to an external controller.


%-----------------------------------------------------------------------------
\subsection{Communication}

Optical motion sensors communicate with an external processor through an
interface which often belongs to standard I/F types, even though some pins
are frequently added for faster or ad-hoc operation -- chip shutdown, chip
selection, flow control, and so on.


\paragraph{Quadrature}
Sensors with only quadrature wave outputs (see \citef{fig:quad_wave}) are now
outdated, because they do not offer any advanced features, and require an
interrupt-driven counter at controller side. On the other hand, quadrature
outputs can be used with any device which natively accepts such signals.


\paragraph{SSP}
When requiring some more flexibility, it is possible to adopt a
\emph{Synchronous Serial Port} in both \emph{Serial Peripheral Interface}
(\emph{SPI}) or \emph{3-wire}, respectively with full-duplex and half-duplex
capabilites, to communicate with motion sensors.

They usually do not require handshaking, even though some control pins are
often used in such a way (e.g. the common \emph{shutdown} pin). Also, the
bit rate is often high enough for simple and fast communication -- from
1~MHz to some tens.

Due to its message-based nature, it is possible not only to read internal
counters, but also to get and set configuration parameters of the target
device.

They can often support multi-master/multi-slave topologies, even though the
most common is single-master/multi-slave. Slaves are usually chosen by a
demultiplexed selection signal, one per slave.

An example of \emph{write} operation over a 3-wire SSP bus is shown in
\citef{fig:ssp_write}. The single master device signals to the single slave
an incoming \emph{write} operation, tells the register address and its value.

An example of \emph{read} operation over the same hardware is shown in
\citef{fig:ssp_read}. The master signals an incoming \emph{read} operation
and tells the address. After that, it lets the slave drive the SDIO line,
then eventually reads the addressed register value.

\begin{figure*}[t]
	\centering
	\includegraphics[keepaspectratio=true,height=1.8cm]{images/ssp_write.pdf}
	\caption{A typical write operation over a half-duplex, 3-wire SSP}
	\label{fig:ssp_write}
\end{figure*}

\begin{figure*}[t]
	\centering
	\includegraphics[keepaspectratio=true,height=1.8cm]{images/ssp_read.pdf}
	\caption{A typical read operation over a half-duplex, 3-wire SSP}
	\label{fig:ssp_read}
\end{figure*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Controller communication protocol comparison}
\label{sec:controller_protocols}

When developing a music-oriented controller, there is always a debate on which
communication standard is the most suitable for the application. The most
common standard are described in the following.


%-----------------------------------------------------------------------------
\subsection{Plain MIDI}

The truly \emph{de-facto} standard in music-oriented communication is the
\emph{Musical Instrument Digital Interface} (\emph{MIDI}). This was
developed in the '80s to be easy and cheap to manufacture, robust and rather
complete for standard music production, with some degree of freedom for
sub-protocols developed by manufacturers. It is still widely supported by
digital music equipment nowadays.

Common output and input circuits can be seen respectively in \citef{fig:midi_out}
and \citef{fig:midi_in}. Basically, it is a standard serial point-to-point
connection based on a common UART powered at TTL levels. Data transmitted by
the UART is converted into current bursts, which light the optocoupler at the
receiver. The optocoupler provides galvanic isolation, so that no
\emph{current loops} can create audible noise in the target device, which used
to be a synthesizer in the first place.

Each MIDI connection can handle up to 16 \emph{channels}, i.e. virtual music
devices. This is enough for common synthesizers, but not to drive an entire
production studio.

The event-based nature of the protocol makes it suitable for most of the
situations, but for events which could be accumulated, or state streaming.
For example, jogwheels could generate way too many motion delta events, usually
as Control Change messages, which would easily flood the entire bus. A packed
streaming state would be better suited in such cases.
Also, when transmitting to a host computer, its operating system (often
time-shared), software buffers can saturate while processing too many events
at a time, or complex sound textures.

The protocol does not support any kind of flow control. Massages can be lost,
partially received (ignored), contain errors, without being corrected or asked
for retransmission. Also, the relatively slow baud rate can generate small
delays between sound generation/control events, which can be detected by
the human brain, which is very sensitive to audio timing.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=0.6\columnwidth]{images/midi_out.pdf}
	\caption{MIDI output circuit, UART sends \emph{OUT} signal}
	\label{fig:midi_out}
\end{figurehere}

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/midi_in.pdf}
	\caption{MIDI input circuit, UART receives \emph{IN} signal}
	\label{fig:midi_in}
\end{figurehere}


\paragraph{Basic protocol}
The serial protocol message word is 8 bits long, with one start (low) and one
stop (high) bits, MSb first, 31250 baud. The protocol is message-driven, with
standard messages 3 bytes long. Special messages are 1 to 3 bytes long, while
manufacturer-defined \emph{System Exclusive} (\emph{SysEx}) messages can be
arbitrarily long. Most of the messages were associated to common synthesizer
features \cite{midi_messages}, even tough manufacturers often interpret them
freely (e.g. through \emph{remapping}).

The first word of a message (control word) is always identified by the MSb
set to 1, while it is always 0 for data words, which are always 7 bits wide.

Standard messages are those referred to the actual music content, such as
\emph{Note On/Off}, \emph{Control Change}, \emph{Pitch Change} and so on,
also called \emph{voice messages}. A timing diagram of a voice message is
shown in \citef{fig:midi_voice_msg}.

The control word identifies the message type and the channel number. The
second word is usually the identifier of the control (key, knob, slider,
wheel, etc.) being actioned, and the third word tells its value or velocity.

Special messages include transport control (time, position), program selection,
system messages, etc. These are advanced messages, often only partially
supported, if not at all, by cheap controllers.

\begin{figure*}[t]
	\centering
	\includegraphics[keepaspectratio=true,width=\textwidth]{images/midi_voice_msg.pdf}
	\caption{Timing diagram of a MIDI voice message}
	\label{fig:midi_voice_msg}
\end{figure*}


\paragraph{Pros}
\begin{itemize*}
	\item \emph{De-facto} standard for digital music equipment
	\item Intuitive message semantics
	\item Simple, robust, noise-free, cheap hardware
\end{itemize*}


\paragraph{Cons}
\begin{itemize*}
	\item Slow communication
	\item No flow control
	\item Low resolution controls
	\item No streaming state support
\end{itemize*}


%-----------------------------------------------------------------------------
\subsection{MIDI/USB}

The \emph{Universal Serial Bus} (\emph{USB}) \cite{usb_docs} is probabily the
most available for consumer electronics interfacing nowadays. Its multipurpose
nature, speed, and robustness, made it the \emph{de-facto} standard for
connecting an actual \emph{universe} of devices. Among this huge load of
devices, also the digital music related ones can be found.

Since the MIDI standard was the most common digital music standard at the time
USB was released, it was convenient to encapsulate it inside USB packets.
So, an \emph{application protocol} was developed over the USB protocol: the
\emph{MIDI over USB} (\emph{MIDI/USB}).

This way, compatibility with standard MIDI interfaces was kept. Production
software and hardware devices kept using it, an so did music production
people. USB is simply the low-level interface, which can be found on all
consumer computers.

MIDI/USB has some advantages over the plain MIDI protocol. Since USB has a
higher baud rate than MIDI, it is possible to reduce delays when handling
many messages in a short interval.

Also, MIDI/USB introduces the concept of \emph{cable}. It supports up to 16
cables, which are 16 virtual plain MIDI devices. This makes theoretically
possible to drive up to 16 hardware synthesizers through a single USB cable,
by dispatching the 16 virtual cables to as many real plain MIDI devices.

The MIDI/USB protocol exploits the features of \emph{bulk} transfers. This
way, packets will not be lost, thanks to the flow control of USB bulk
transfers.

USB devices can also show many indipendent behaviors, by choosing different
application protocols per each USB endpoint. For example, this allows to have
a MIDI/USB device with an integrated HID/USB trackpad,
by using a single USB cable, like the \emph{M-Audio Torq Xponent}
\cite{maudio_xponent}.

All the MIDI drawbacks are kept, except for the baud rate and flow control.
The USB, by its time-shared nature, always introduces some delays -- at
least 1~ms per query, and a few milliseconds for software stack processing.
As a drawback of bulk transfers, the delivering time is uncertain, because
many retansmissions can be issued, or there is not enough free bandwidth on
the bus, introducing even more delay.


\paragraph{Basic protocol}
The MIDI/USB protocol is a \emph{sub-class} of the \emph{Audio class}, defined
by the USB standard \cite{usb_docs}. This parent class is oriented to audio
equipment communication and control -- speakers, microphones, keyboards,
controllers, synthesizers, DSPs can all be driven by this class.

The packet is composed by a \emph{header byte}, and the remaining 3 bytes are
the encapsulated MIDI packet -- all but the SysEx messages, which have variable
length. The header byte addresses the cable, and defines the following MIDI
message type -- some bytes can be unused, and thus ignored by the USB parser.
SysEx messages are simply split into 3-bytes chunks, merged by the USB parser
when the trailing byte(s) are received.

The protocol supports \emph{bulk} USB transfers. They add flow control to bare
USB streams, which in order adds flow control to the encapsulated MIDI stream.
Bulk packets have the lowest priority over the USB bus, which could introduce
delays when the bus is saturated by \emph{interrupt} and \emph{isochronous}
endpoint transfers. Also, packet handshaking and retransmission may add
some delay too.


\paragraph{Pros}
\begin{itemize*}
	\item USB is \emph{de-facto} standard for consumer electronics
	\item Much higher bandwidth than plain MIDI
	\item Up to 16 virtual cables
	\item Multi-purpose device through a single USB cable
\end{itemize*}


\paragraph{Cons}
\begin{itemize*}
	\item All the MIDI drawbacks, except for baud rate and flow control
	\item Delays introduced by USB time-sharing and bulk transfers
\end{itemize*}


%-----------------------------------------------------------------------------
\subsection{HID/USB}

Besides MIDI/USB, another application protocol was developed to handle those
devices which interface with human beings, and is much widely implemented.
The \emph{Human Interface Device} (\emph{HID}) \cite{hid_info}, in fact, is an
USB class with huge flexibility and support -- it can be found in almost any
USB device with keys, knobs, sliders, simple displays, LEDs, control wheels,
and so on.

USB endpoints for HID applications are scheduled with \emph{interrupt}
priority. This means that HID is suitable for low-latency devices, but does
not offer high bandwidth.

A strength of the HID protocol is that it is highly available. Any decent host
OS has full native support for it. Also, HID reports are described upon
connection, and the host can actually parse not only the bare syntax, but also
its semantics for some common cases -- keyboards, joysticks, gloves,
\emph{etc}. This often makes the device immediately available to the user,
without the need of custom device drivers.

Being developed over the USB protocol, HID packets suffer from USB scheduling
delays. This means that a \emph{USB full speed} device has a minimum latency
of 1~ms between its packets -- the minimum \emph{interrupt} latency.


\paragraph{Basic protocol}
The HID protocol is based on the exchange of \emph{report} packets. A report
has a structure described in the setup phase of the USB HID class interface.
Its size is constrained by that of USB \emph{interrupt} packets, so it cannot
contain too much data. By the way, it is big enough to support \emph{state
streaming} of a small set of data, or to describe a few events per packet.

State streaming becomes handy when tracking the status of some critical or
rapidly changing data sent by the device. In the case of the simplified RATT
prototype (see Section~\ref{sec:simplified_approach}), deltas and absolute
positions of both the mouse sensor and the incremental encoder are
continuously streamed. This optimizes the USB bandwidth usage. In fact, those
devices would generate a huge number of motion events if sent with an
event-based protocol, like MIDI/USB, wasting the available bandwidth and
introducing queuing delays.

The exchange of HID reports is straightforward, but the report definitions
need some attention. As told before, the HID report structure must be
communicated when configuring the HID connection, with a \emph{Report}
descriptor. This descriptor is written in a dedicated language
\cite{hid_docs}, which might be tricky -- some tools are available to help the
design of such descriptors.


\paragraph{Pros}
\begin{itemize*}
	\item Natively supported by most operating systems
	\item USB \emph{interrupt} priority
	\item Suitable for small state streaming
	\item Common semantics automatically inferred
\end{itemize*}


\paragraph{Cons}
\begin{itemize*}
	\item Sill some USB delays
	\item Custom HID reports to design
\end{itemize*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simplified proposed approach}
\label{sec:simplified_approach}

The proposed approach was developed so that it is possible to achieve good
performance both at high and low speeds, without introducing expensive parts.

The main idea is to use a mouse sensor to measure slow local motions, which
are difficult to process with timecode, and need high resolution jogwheels.
As seen in the previous section, this is not possible with cheap designs.

Slow local motions are common when scratching or trying to reposition the
virtual needle of the emulated turntable, for example when the DJ is searching
for a good point where to start playing from (\emph{cue} point).

When the disc is spinning at cruise speed, or when the rotation is fast
enough, the classic methods can be used to keep track of the position.
Mouse sensors, in fact, are not able to keep track of absolute movements,
especially when they are very fast. Anyway, even cheap sensors have a
resolution in the order of several hundreds, if not thousands, DPIs nowadays.

As proven later, the disc can theoretically be divided in thousands slices,
thus providing a local resolution higher than the most expensive encoders on
the market -- obviously in the set of those affordable for a DJ, not the
state-of-the-art encoders for hi-end industrial machineries.

In the following, a simplified prototype will be presented. A low-end MCU and
a standard COTS mouse sensor were chosen, just to see if it is possible to
achieve good performance with a simple circuit.


%-----------------------------------------------------------------------------
\subsection{Hardware architecture}

The simplified prototype has a very crude hardware architecture. It is split
into three modules: the \emph{controller board} (aka \emph{main board}), the
\emph{sensor board} and an optional \emph{timecode preamp board} for the use
with timecoded media. This subdivision was done just to decouple the
controller with the sensor, for further experiments with other hardware
configurations.


\paragraph{Controller board}
The controller board in \citef{fig:board_photo} hosts the MCU, a
\emph{PIC18LF14K50} \cite{microchip_pic18lf14k50} by \emph{Microchip}, which
is a 8-bits MCU running at 48~MHz (16 MIPS). It is fast enough to handle a
single wheel, but nothing more advanced such as DSP, which is left to the
user software application.

This board also mounts the voltage regulator, to get 3.3~V from the standard
5~V sourced by the USB host. Bulk capacitors keep it stable.

There are also a user button for input, and three LEDs for user interactions.

A standard UART can be used for basic messaging with an optional text console.

There are also two pins dedicated for an additional quadrature encoder input.
They can be configured to be directly coupled with the MCU comparator
interrupts, in order to trigger encoder changes.

To communicate with the sensor module some control and interrupt signals, and
a half-duplex serial port are provided.

The USB bus is directly connected to the MCU, which has an internal
\emph{Serial Interface Engine} configured for \emph{Full speed} transfers.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/board_photo.jpg}
	\caption{The controller prototype board}
	\label{fig:board_photo}
\end{figurehere}


\paragraph{Sensor board}
The sensor board in \citef{fig:sensor_photo} simply hosts the mouse sensor,
the surface illumination LED, and the lens. The sensor is an \emph{ADNS-2080}
\cite{avago_adns2080} by \emph{Avago}. It is a sensor aimed at office users,
with average performance and low cost. As for the MCU, higher performance
modules are on the market, but the challenge of this proposal was to find a
basic average solution, which can be improved with further research. Briefly,
the sensor can reach an interesting resolution of up to 2000~DPI, and motion
speed up to 30~in/s (76.2~cm/s). There is no guarantee of constant latencies,
because the clock speed is variable.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/sensor_photo.jpg}
	\caption{The optical motion sensor prototype board}
	\label{fig:sensor_photo}
\end{figurehere}


\paragraph{Timecode preamp board}
An optional board, seen in \citef{fig:preamp_photo}, was designed to properly
amplify a \emph{Line} -- no \emph{Phono}! -- timecode signal so that it can be
recognized by comparators of the controller board.

Each audio channel can be amplified in amplitude, by controlling the inverting
gain of the opamp with a potentiometer. A spare opamp generates the $V_{DD}/2$
voltage reference for single-supply conditioning.

Two LEDs help the user in keeping the overall timecode level compatible with
the comparator inputs on the controller board, by warning if the signal is
near saturation, or too low to be squared correctly by comparators.
In fact, when the volume is too low or saturates, the sinusoidal timecode
signals won't be squared with 50\% duty cycle, which can generate some jitter.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/preamp_photo.jpg}
	\caption{The timecode preamplifier prototype board}
	\label{fig:preamp_photo}
\end{figurehere}


%-----------------------------------------------------------------------------
\subsection{Firmware architecture}

Due to the lack of a \emph{Real-Time Operating System} (\emph{RTOS}) support
on the chosen MCU, the application is written in a \emph{while-loop} fashion,
with \emph{interrupt-driven} tasks at \emph{high priority}.

A logical view of the implemented firmware framework is depicted in
\citef{fig:fw_simp}.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,scale=0.4]{images/fw_simp.pdf}
	\caption{Logical view of the simplified firmware architecture}
	\label{fig:fw_simp}
\end{figurehere}


\paragraph{Bootloader}
In order to simplify firmware deployment, a HID bootloader is added to the
development prototype. This fills the first 2048 words of the program space,
which is not that small. The bootloader is the one provided by the
\emph{Microchip Application Libraries} \cite{microchip_mal}, and implements
HID control.

The bootloader can be called by plugging RATT into the USB host socket, while
pressing the user button. The developer can then use the HID bootloader
software provided by Microchip to download the complied HEX executable to the
program memory of the MCU.


\paragraph{HID/USB module}
The HID/USB module is devloped over the \emph{HID Simple Custom Demo}
provided with the \emph{Microchip Application Libraries} \cite{microchip_mal},
using the \emph{USB Framework} version \emph{2.9d}. The code itself is almost
the same, so please refer to the documentation delivered by Microchip for more
information, as the topic is very complex and cannot be described in a few
words here.

RATT is a simple I/O HID device, which uses the endpoint 1 for both input and
output transfers. In the following, the descriptors used by HID/USB will be
described briefly.

\citet{tab:usb_device_desc} shows the \emph{Device} descriptor. It tells the
host it is a standard USB 2.0 device, with its vendor and product identifiers
(dummy in this case), with only one configuration. It also indicates there
are a manufacturer and product name strings to be received and indexed later.

\begin{tablehere}
\centering \footnotesize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1	& Number	& 18		\\
1	& bDescriptorType		& 1	& Constant	& 0x01		\\
2	& bcdUSB				& 2	& BCD		& 0x0200	\\
4	& bDeviceClass			& 1	& Class		& 0x00		\\
5	& bDeviceSubClass		& 1	& SubClass	& 0x00		\\
6	& bDeviceProtocol		& 1	& Protocol	& 0x00		\\
7	& bMaxPacketSize		& 1	& Number	& 8			\\
8	& idVendor				& 2	& ID		& 0xDEAD	\\
10	& idProduct				& 2	& ID		& 0xBEEF	\\
12	& bcdDevice				& 2	& BCD		& 0x0002	\\
14	& iManufacturer			& 1	& Index		& 1			\\
15	& iProduct				& 1	& Index		& 2			\\
16	& iSerialNumber			& 1	& Index		& 0			\\
17	& bNumConfigurations	& 1	& Integer	& 1			\\
\hline
\end{tabular}
\caption{USB \emph{Device} descriptor}
\label{tab:usb_device_desc}
\end{tablehere}

The single \emph{Configuration} descriptor in \citet{tab:usb_config_desc}
tells the host that the device is powered by the USB bus at 100~mA maximum,
and there is only one interface for this configuration.

\begin{tablehere}
\centering \footnotesize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1	& Number	& 9				\\
1	& bDescriptorType		& 1	& Constant	& 0x02			\\
2	& wTotalLength			& 2	& Number	& 41			\\
4	& bNumInterfaces		& 1	& Number	& 1				\\
5	& bConfigurationValue	& 1	& Number	& 1				\\
6	& iConfiguration		& 1	& Index		& 0				\\
7	& bmAttributes			& 1	& Bitmap	& 0b11000000	\\
8	& bMaxPower				& 1	& mA/2		& 50			\\
\hline
\end{tabular}
\caption{USB \emph{Configuration} descriptor}
\label{tab:usb_config_desc}
\end{tablehere}

The single \emph{Interface} descriptor in \citet{tab:usb_intf_desc} simply
indicates that it is a HID device (HID class). All the other options are
ignored for this device.

\begin{tablehere}
\centering \footnotesize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1	& Number	& 9			\\
1	& bDescriptorType		& 1	& Constant	& 0x04		\\
2	& bInterfaceNumber		& 1	& Number	& 0			\\
3	& bAlternateSetting		& 1	& Number	& 0			\\
4	& bNumEndpoints			& 1	& Number	& 2			\\
5	& bInterfaceClass		& 1	& Class		& 0x03		\\
6	& bInterfaceSubClass	& 1	& SubClass	& 0			\\
7	& bInterfaceProtocol	& 1	& Protocol	& 0			\\
8	& iInterface			& 1	& Index		& 0			\\
\hline
\end{tabular}
\caption{USB \emph{Interface} descriptor}
\label{tab:usb_intf_desc}
\end{tablehere}

The \emph{HID Class-specific} descriptor in \citet{tab:hid_class_desc} is for
the HID 1.11 protocol, no country-specific address, with a single HID report
descriptor 48 bytes long.

\begin{tablehere}
\centering \footnotesize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1	& Number	& 9			\\
1	& bDescriptorType		& 1	& Constant	& 0x21		\\
2	& bcdHID				& 2	& BCD		& 0x0111	\\
4	& bCountryCode			& 1	& Number	& 0x00		\\
5	& bNumDescriptors		& 1	& Number	& 1			\\
6	& bDescriptorType		& 1	& Constant	& 0x22		\\
7	& wDescriptorLength		& 2	& Number	& 48		\\
\hline
\end{tabular}
\caption{HID \emph{Class-specific} descriptor}
\label{tab:hid_class_desc}
\end{tablehere}

The USB \emph{Endpoint} descriptors in \citet{tab:usb_ep1i_desc} and
\citet{tab:usb_ep1o_desc} refer to the bidirectional endpoint 1, used to
handle HID transfers, polled each 1~ms with \emph{interrupt} scheduling.
Since the user needs very fast responses for very few data from the motion
sensor (16 bytes per report), these settings are optimal for the device
being developed.

\begin{tablehere}
\centering \footnotesize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1	& Number	& 7				\\
1	& bDescriptorType		& 1	& Constant	& 0x05			\\
2	& bEndpointAddress		& 1	& Number	& 0x81			\\
4	& bmAttributes			& 1	& Bitmap	& 0b00000011	\\
5	& wMaxPacketSize		& 2	& Number	& 16			\\
6	& bInterval				& 1	& ms		& 1				\\
\hline
\end{tabular}
\caption{USB IN \emph{Endpoint} 1 descriptor}
\label{tab:usb_ep1i_desc}
\end{tablehere}

\begin{tablehere}
\centering \footnotesize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1	& Number	& 7				\\
1	& bDescriptorType		& 1	& Constant	& 0x05			\\
2	& bEndpointAddress		& 1	& Number	& 0x01			\\
4	& bmAttributes			& 1	& Bitmap	& 0b00000011	\\
5	& wMaxPacketSize		& 2	& Number	& 16			\\
6	& bInterval				& 1	& ms		& 1				\\
\hline
\end{tabular}
\caption{USB OUT \emph{Endpoint} 1 descriptor}
\label{tab:usb_ep1o_desc}
\end{tablehere}

As told before, manufacturer and product names are indexed inside the Device
descriptor. The language code and those names are defined by the \emph{String}
descriptors shown in \citet{tab:usb_lang_desc}, \citet{tab:usb_manuf_desc},
and \citet{tab:usb_prod_desc}.

\begin{tablehere}
\centering \footnotesize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1	& Number	& 4				\\
1	& bDescriptorType		& 1	& Constant	& 0x03			\\
2	& wString				& 2	& Unicode	& 0x0409		\\
\hline
\end{tabular}
\caption{USB \emph{Language Code} string descriptor}
\label{tab:usb_lang_desc}
\end{tablehere}

\begin{tablehere}
\centering \footnotesize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1		& Number	& 12			\\
1	& bDescriptorType		& 1		& Constant	& 0x03			\\
2	& wString				& 10	& Unicode	& "TexZK"		\\
\hline
\end{tabular}
\caption{USB \emph{Manufacturer} string descriptor}
\label{tab:usb_manuf_desc}
\end{tablehere}

\begin{tablehere}
\centering \footnotesize
\begin{tabular}{|r|l|c|l|r|}
\hline
\textbf{Offset} & \textbf{Field} & \textbf{Size} & \textbf{Type} & \textbf{Value}	\\
\hline
0	& bLength				& 1	& Number	& 10			\\
1	& bDescriptorType		& 1	& Constant	& 0x03			\\
2	& wString				& 8	& Unicode	& "RATT"		\\
\hline
\end{tabular}
\caption{USB \emph{Product} string descriptor}
\label{tab:usb_prod_desc}
\end{tablehere}

Finally, the HID \emph{Report} descriptor in \citet{tab:hid_rpt_desc}
describes the syntax and semantics of the actual data being transferred by the
device application. Because of the custom semantics, the descriptor simply
indicates 16 bytes for both input and output transfers. Semantics of the
\emph{IN} (device-to-host) report are listed in \citef{fig:hid_rpt_struct},
while that of the \emph{OUT} report is currently reserved.

\begin{tablehere}
\centering \footnotesize
\begin{tabular}{|rl|rl|}
\hline
\textbf{Field} & & \textbf{Value} &		\\
\hline
0x06	& Usage Page		& 0xFF00	& Vendor Defined Page 1		\\
0x09	& Usage				& 0x01		& Vendor Usage 1			\\
0xA1	& Collection		& 0x01		& Application				\\
\hline
0x19	& Usage Minimum		& 16		& 							\\
0x29	& Usage Maximum		& 16		&							\\
0x15	& Logical Minimum	& 0x00		&							\\
0x25	& Logical Maximum	& 0xFF		&							\\
0x75	& Report Size		& 8			& field bits				\\
0x95	& Report Count		& 16		& 							\\
0x81	& Input				& 0x00		& Data, Array, Abs			\\
0x19	& Usage Minimum		& 16		& 							\\
0x29	& Usage Maximum		& 16		&							\\
0x95	& Report Count		& 16		& 							\\
0x91	& Output			& 0x00		& Data, Array, Abs			\\
\hline
0xC0	& End Collection	&			&							\\
\hline
\end{tabular}
\caption{HID IN \emph{Report} descriptor}
\label{tab:hid_rpt_desc}
\end{tablehere}

\begin{figurehere}
\begin{mdframed}[
%	backgroundcolor=lightyellow,
%	hidealllines=true,
	innerleftmargin=4pt,
	innerrightmargin=4pt,
	innertopmargin=0pt,
	innerbottommargin=0pt
]
\begin{lstlisting}[
	language=C,
	basicstyle=\scriptsize\ttfamily,
	keywordstyle=\color{darkblue},
	identifierstyle=\color{darkred},
	commentstyle=\color{darkgreen}
]
typedef struct {
  unsigned long   timestamp;    // milliseconds
  struct {
    signed short    dx;         // X motion
    signed short    dy;         // Y motion
  }               sensorMotion; // sensor motion
  struct {
    unsigned short  x;          // X position
    unsigned short  y;          // Y position
  }               sensorPos;    // sensor position
  signed short    incencMotion; // encoder motion
  unsigned short  incencPos;    // encoder position
} APP_HID_TX_REPORT;
\end{lstlisting}
\end{mdframed}
\caption{HID IN report semantics}
\label{fig:hid_rpt_struct}
\end{figurehere}



\paragraph{LED module}
The LED module simply drives the three LEDs on and off.


\paragraph{Encoder module}
A small software module (\emph{incenc}) decodes the quadrature signal fed by a
rotary encoder, or exploited from a properly timecoded media stream.

The quadrature encoder waves are gathered by the MCU by triggering interrupts
in a rather tricky way. The two quadrature inputs, namely \emph{A} and
\emph{B}, are connected to the negative inputs of the two comparators of the
chosen MCU. The comparators have an internal reference (positive input)
voltage fed by the internal DAC module at $V_{DD}/2$, with a small hysteresis.

Whenever the quadrature signal (A or B) crosses the reference voltage, an
high priority interrupt is generated. The ISR detects the current quadrature
phase and accumulates the single step into a global delta counter.

The delta counter can then be collected by the (slower) HID report generator,
which resets it.

The initialization routine simply configures the voltage reference DAC, the
two comparators, and interrupts.

There is no background service, since all the processing is triggered by
interrupt events.


\paragraph{Sensor module}
Another software module (\emph{adns2080}) handles the mouse sensor. This
module provides communication rountines over the SPI port of the MCU in a
half-duplex fashion.

All the communication routines are blocking, but this is not a problem because
they are executed in the background service (main loop) of the firmware
architecture.

An initialization routine configures the SPI port, then the mouse sensor. Its
setup will allow for top-performance (no low-power states), 12-bits deltas
reporting, and active-low level-sensitive motion interrupt generation.
This routine will also check for proper communication with the daughter board.

The high-priority motion interrupt is generated by the sensor whenever motion
is detected. This interrupt is cached by raising a firmware flag. The high
priority level will minimize CPU cycles for this very simply operation.

The background service polls for the interrupt flag, and starts a \emph{motion
burst} read, which collects motion deltas over the serial port by minimizing
dead times. Deltas are accumulated on global counters, which will be gathered
by the HID report generator and thuse reset.


\paragraph{Main module}
The main module, also called the \emph{app}, initializes the system, handles
the main loop, and provides some interrupt functions.

The initialization sequence calls the initialization of all the sub-modules.

The main loop cycles through the \emph{service task} of the sub-modules, so
that motion deltas are computed for both the sensor and incremental encoder
modules. If the deltas are meaningful and the HID transmission endpoint is
available, a new HID report is built and sent to the host.

The two interrupt handlers, one for high-priority and one for low-priority
interrupts, will obviously handle events generated by peripherals.

Some functions are dedicated to locking and unlocking of the application
resources, and are basically wrappers respectively to global interrupt disable
and enable.


\paragraph{Tasks organization}
The modules are organized in a \emph{while-loop} fashion, because the chosen
MCU has not enough computational power, nor a stack manageable by an actual
RTOS.

An initialization procedure will turn all the modules on, and enables
interrupts. After that, the main loop is entered.

Inside the main loop, incremental encoder and mouse sensor deltas are gathered
and, if the USB endpoint is free, sent by an HID report.

Fast and simple interrupt events are processed by the high-priority ISR, while
communication events, which are slower, are processed by the low-priority ISR.


%-----------------------------------------------------------------------------
\subsection{Software architecture}

Thanks to the adoption of the HID standard, host software can communicate with
the device easily. In fact, all the major operating systems have full support
for the USB stack, including the HID application protocol.

The target software for RATT is a \emph{vinyl emulation software}. There is a
huge load of programs to emulate traditional DJ consoles, but not so many 
support HID controllers, and fewer let the user define his own mappings. Among
all of them, the reference software is \emph{Virtual~DJ} by \emph{Atomix
Productions} \cite{atomix_vdj}, available for both Microsoft Windows and Apple
MacOSX.


\paragraph{HID/USB connectivity}
Connection between Virtual~DJ and RATT is straightforward. This software has
native support for HID devices, which are \emph{plug and play} and
\emph{hot-pluggable}.

After connection, Virtual~DJ searches for a valid mapping for the device. If
found, it is immediately loaded, otherwise the invalid device is simply
ignored.


\paragraph{Device description}
In order to be considered, a device must supply the device definition to
Virtual~DJ, in this case for a HID device \cite{vdj_hiddef} as seen in
\citef{fig:vdj_device_def}. The VID and PID are the actual HID device
identifier, and the HID report size is specified. The device supports only one
deck at a time.

The device description is divided in four pages. The \emph{init} and
\emph{exit} pages should contain information for both initialization and
deinitialization respectively, and are ignored. The \emph{out} page is ignored
too, because the device does not receive any meaningful messages from the
host software.

Instead, the \emph{in} page contains the description of the three motion
sources. They are all interpreted as jogwheels, with full 16-bit unsigned
counters which keep track of the accumulated position. The \emph{full}
attribute tells the jogwheel CPR, and needs to be calibrated with geometrical
parameters of the wheel itself.

On Windows, the XML text must be saved in:\\
{\ttfamily\small {\%}UserProfile{\%}/Documents/VirtualDJ/Devices/}\\
while on MacOSX in:\\
{\ttfamily\small {\textasciitilde}/Documents/VirtualDJ/Devices/}\\
for example as {\ttfamily\small ratt{\_}device.xml}.

\begin{figurehere}
\begin{mdframed}[
%	backgroundcolor=lightyellow,
%	hidealllines=true,
	innerleftmargin=4pt,
	innerrightmargin=4pt,
	innertopmargin=0pt,
	innerbottommargin=0pt
]
\begin{lstlisting}[language=simpleXML]
<?xml version="1.0" encoding="UTF-8"?>
<device name="RATT" author="Andrea Zoppi" decks="1"
 type="HID" vid="0xDEAD" pid="0xBEEF"
 reportsize="16">
  <page type="init">
    <!-- Nothing to initialize -->
  </page>
  <page type="in">
    <!-- Optical motion sensor X position -->
    <jog name="SENSOR_POS_X"
     byte="8" size="word" endian="little"
     full="50265" min="0" max="65535"/>
    <!-- Optical motion sensor Y position -->
    <jog name="SENSOR_POS_Y"
     byte="10" size="word" endian="little"
     full="50265" min="0" max="65535"/>
    <!-- Incremental encoder position -->
    <jog name="INCENC_POS"
     byte="14" size="word" endian="little"
     full="4000" min="0" max="65535"/>
  </page>
  <page type="out">
    <!-- No outputs -->
  </page>
  <page type="exit">
    <!-- Nothing to deinitialize -->
  </page>
</device>
\end{lstlisting}
\end{mdframed}
\caption{Virtual~DJ device definition for RATT}
\label{fig:vdj_device_def}
\end{figurehere}


\paragraph{Device mapping}
Once the device is recognized by Virtual~DJ, it needs to be \emph{mapped}
\cite{vdj_mapping}. The mapping process associates a control event, declared
by the device definition, to some actions. These actions are executed by
parsing the \emph{VDJscript} syntax \cite{vdj_script}.

For demonstration purposes, only the optical motion sensor X position will be
processed as jogwheel position by the software, while the Y position and the
quadrature position will be ignored.

The XML text in \citef{fig:vdj_device_map} summarizes the actions being
mapped. On Windows, it must be saved in:\\
{\ttfamily\small {\%}UserProfile{\%}/Documents/VirtualDJ/Mappers/}\\
while on MacOSX in:\\
{\ttfamily\small {\textasciitilde}/Documents/VirtualDJ/Mappers/}\\
for example as {\ttfamily\small ratt{\_}mapping.xml}.

\begin{figurehere}
\begin{mdframed}[
%	backgroundcolor=lightyellow,
%	hidealllines=true,
	innerleftmargin=4pt,
	innerrightmargin=4pt,
	innertopmargin=0pt,
	innerbottommargin=0pt
]
\begin{lstlisting}[language=simpleXML]
<?xml version="1.0" encoding="UTF-8"?>
<mapper device="RATT" author="Andrea Zoppi"
 description="RATT" version="704" date="10/08/2012">
  <!-- Use the sensor X position as a jogwheel -->
  <map value="SENSOR_POS_X" action="jogwheel"/>
  <!-- Ignore the sensor Y position -->
  <map value="SENSOR_POS_Y" action="nothing"/>
  <!-- Ignore the incremental encoder input -->
  <map value="INCENC_POS" action="nothing"/>
</mapper>
\end{lstlisting}
\end{mdframed}
\caption{Virtual~DJ device mapping for RATT}
\label{fig:vdj_device_map}
\end{figurehere}


%-----------------------------------------------------------------------------
\subsection{Sizing and computations}

The device must be able to keep track of turntable movements. This can be
achieved only if the platter is moving at less than the maximum speed that
the optical motion sensor can reach. Given this constraint, it is possible to
determine the radius at which the center of the sensor can be placed. In the
following, some computations will lead to the expected results.


\paragraph{Turntable}
Nominal turntable data can be found in \citet{tab:tt_data_nom}. Nominal
settings are for a \ttDiscDiam\ inches disc, spinning at \ttNomAngSpeed\ 
rotations per minute, with no pitch correction.

Computations are done with well-known basic equations.

\begin{tablehere}
\centering \footnotesize
\begin{tabular}{|l|l|rl|}
\hline
\textbf{Name} & \textbf{Description} & \textbf{Value} &	\\
\hline
ttDiscDiam		& Disc diameter			& $\ttDiscDiam$		& in			\\
ttNomAngSpeed	& Nominal angular speed	& $\ttNomAngSpeed$	& rot/min		\\
ttPitchOff		& Pitch offset			& $\ttPitchOff$		& \%			\\
\hline
ttDiscPerim		& Disc perimeter		& $\ttDiscPerim$	& in			\\
ttAngSpeed		& Angular speed			& $\ttAngSpeed$		& rot/min		\\
ttRevRate		& Revolution rate		& $\ttRevRate$		& Hz			\\
ttRevTime		& Revolution time		& $\ttRevTime$		& s				\\
ttTgSpeed		& Tangential speed		& $\ttTgSpeed$		& in/s			\\
\hline
\end{tabular}
\caption{Nominal turntable data}
\label{tab:tt_data_nom}
\end{tablehere}


\paragraph{Sensor}
Optical motion sensor computations are very easy. Given the sensor resolution
and maximum speed, it is possible to know the maximum theoretical dots count
per second.

Also, the HID configuration of the device indicates a polling interval of
1~ms, so it is useful to know the maximum counter value in that that time
interval. Since RATT is using a 12-bits report count, counters will never be
saturated even with some jitter in the main loop of the firmware.

Data can be found in \citet{tab:ss_data}.

\begin{tablehere}
\centering \footnotesize
\begin{tabular}{|l|l|rl|}
\hline
\textbf{Name} & \textbf{Description} & \textbf{Value} &	\\
\hline
ssRes			& Resolution			& $\ssRes$			& dot/in		\\
ssMaxSpeed		& Maximum speed			& $\ssMaxSpeed$		& in/s			\\
\hline	
ssMaxDotRate	& Maximum dots rate		& $\ssMaxDotRate$	& dot/s			\\
ssMaxDotOneMs	& Maximum dots in 1~ms	& $\ssMaxDotsOneMs$	& dot			\\
\hline
\end{tabular}
\caption{Optical motion sensor data}
\label{tab:ss_data}
\end{tablehere}


\paragraph{Measurement}
Finally, it is possible to define the measurement environment. The center of
the motion sensor must be placed at an appropriate distance from the disc
center, so that motion can always be detected correctly. This means that the
speed of the disc below the sensor is always lower than the maximum speed
detectable by the sensor itself.

Consider the case of the Y direction of the sensor being perpendicular to the
tangential velocity. The X counter represents the number of virtual dots been
measured by the sensor until that time, while the Y counter should always be
clear.

The disc is supposed to spin at nominal angular speed, so after a single full
revolution the X counter tells how many dots make the perimeter at that
radius.

By choosing a measurement radius of \mmRadius\  inches, even when spinning at
twice the nominal speed the sensor should measure the speed correctly. In
fact, the speed is less than half of the maximum reachable by the sensor.

Results are shown in \citet{tab:mm_data_nom}, while an example of placement
can be seen in \citef{fig:ratt_placement}.

\begin{tablehere}
\centering \footnotesize
\begin{tabular}{|l|l|rl|}
\hline
\textbf{Name} & \textbf{Description} & \textbf{Value} &	\\
\hline
mmRadius		& Radius				& $\mmRadius$		& in			\\
mmAngleOff		& Angle offset			& $\mmAngleOff$		& $^{\circ}$	\\
\hline
mmRadiusCm		& Radius [cm]			& $\mmRadiusCm$		& cm			\\
mmPerim			& Measurement perimeter	& $\mmPerim$		& in			\\
mmSpeed			& Speed					& $\mmSpeed$		& in/s			\\
mmDotRate		& Dots rate				& $\mmDotRate$		& dot/s			\\
mmRevDots		& Revolution dots		& $\mmRevDots$		& dot			\\
\hline
\end{tabular}
\caption{Nominal measurement data}
\label{tab:mm_data_nom}
\end{tablehere}

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=0.6\columnwidth]{images/ratt_placement.pdf}
	\caption{Sensor placement over a 12'' vinyl record}
	\label{fig:ratt_placement}
\end{figurehere}


%-----------------------------------------------------------------------------
\subsection{Field results}

Some empirical test were performed to check the goodness of the chosen
approach.

First, some timing tests will determine if the device is rapid enough to
handle fast changes in speed, without delays noticeable by an average DJ.

Moreover, some space tests will show if the motion sensor alone is capable
of keeping track of absolute motions, with a small accumulated displacement
error.

Finally, an opinion about the overall feeling of the device behavior will be
given.


\paragraph{Motion detection rate}
A first test measures the interval between \emph{MOTION} interrupts called by
the optical motion sensor. The sensor does not have a fixed acquisition clock,
but instead it is adapted on the speed of the moving surface beneath.

When moving at a fairly slow speed, the interval between interrupts is around
3.7~ms (4~ms inside the datasheet) as seen in \citef{fig:motion_delay_slow}.

When the moving surface gets faster, the interrupt generation slows down at
about half that speed, with an interval around 7.2~ms, as shown in
\citef{fig:motion_delay_fast}.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/motion_delay_slow.png}
	\caption{\emph{MOTION} interrupt delay for slow steady speed}
	\label{fig:motion_delay_slow}
\end{figurehere}

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/motion_delay_fast.png}
	\caption{\emph{MOTION} interrupt delay for fast steady speed}
	\label{fig:motion_delay_fast}
\end{figurehere}


\paragraph{Motion processing time}
After being issued, the \emph{MOTION} interrupt has to be processed. The
sensor is configured so that the interrupt signal goes low when motion is
detected, then is kept low until all the motion counters are read, going back
high after the reading.

By measuring this delay, it is possible to know how long it takes for the MCU
to read those counters after the \emph{MOTION} interrupt is reported. As
captured in \citef{fig:motion_pulse_typ}, the processing takes typically
30~{\textmu}s, with a maximum of 72~{\textmu}s in \citef{fig:motion_pulse_max}.

This delay is clearly negligible, and does not affect the overall latency nor
the internal motion sensor counters.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/motion_pulse_typ.png}
	\caption{Typical \emph{MOTION} pulse duration}
	\label{fig:motion_pulse_typ}
\end{figurehere}

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/motion_pulse_max.png}
	\caption{Maximum \emph{MOTION} pulse duration}
	\label{fig:motion_pulse_max}
\end{figurehere}


\paragraph{HID motion processing time}
A final timing test will prove that the MCU is fast enough to handle HID
transactions in time.

As an extension of the previous test, the measured delay adds the time needed
to build and buffer the HID report into the hardware USB RAM. A LED signal was
used to draw the processing length.

The minimum and maximum delays can be extracted by \citef{fig:motion_tot_min}
and \citef{fig:motion_tot_max}. The delay is thus in the range of 74~{\textmu}s
to 110~{\textmu}s, which is still negligible for the purpose.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/motion_tot_min.png}
	\caption{Minimum \emph{MOTION} interrupt total time}
	\label{fig:motion_tot_min}
\end{figurehere}

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/motion_tot_max.png}
	\caption{Maximum \emph{MOTION} interrupt total time}
	\label{fig:motion_tot_max}
\end{figurehere}


\paragraph{Absolute tracking}
\TODO absolute position after 10 scratches


\paragraph{Overall feeling}
The overall feeling is good. The latency is low enough -- comparable to that
of the soundcard, which is still dominant -- and it is possible to scratch
with ease, even though very fast scratches feel a bit odd.

Anyway, when trying to reposition the virtual needle the precision is very
high, altough the absolute tracking of the sensor alone is not as accurate as
with the help of an incremental encoder. Such a good precision is comes handy
also when using the jogwheel to push/pull the virtual vinyl -- usually called
\emph{nudge} operations.

The software seems to handle the workload with no stress on the CPU, even with
high deltas.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Advanced proposed approach}
\label{sec:advanced_approach}

Due to the few capabilities of the simplified approach, which is just for
basic research and demonstration purposes, a more advanced way to achieve
better results is presented in the following. No prototype was made, but a
high-level description of the target architecture can drive the development
of an actual device.

Basically, the advanced approach exploits the computational power of the most
recent MCUs, in order to provide faster motion detection and processing rate,
as well as the opportunity to handle tasks outside those for the motion
detection.

The whole system will be capable to manage a wide range of input devices --
buttons, sliders, jogwheels -- and some displayed information. The workload is
split into simple \emph{tasks}, handled by a \emph{Real-Time Operating System}
so that it will be easier to develop the firmware.


%-----------------------------------------------------------------------------
\subsection{Hardware architecture}

The generic architecture reflects that of complex digital DJ controllers
which offer jogwheels (often touch-sensitive), but also buttons, knobs,
sliders, lights, displays, external connections, audio piping to DSP, and so
on.

By choosing a fully-featured MCU of nowadays, such as the \emph{STM32~F4}
series \cite{st_stm32f4}, it is possible to handle almost all these devices
with only one MCU, at reduced overall price. Obviously, some additional chips
are still needed -- motion sensors \emph{in primis} -- but the whole
architecture can be shrunk into a few chips.


\paragraph{Digital inputs}
The most basic type of inputs is \emph{discrete-state} (\emph{digital)} input
devices, such as buttons, switches, toggles, and so on. In order to handle
them, a \emph{matrix} topology often suffices, such as the one seen in
\citef{fig:keypad}. Such matrix can be scanned row-by-row, active low logic,
with full support for multiple elements active at the same time.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=0.8\columnwidth]{images/keypad.pdf}
	\caption{$ 3 \times 3 $ keypad, active low, multiple key presses}
	\label{fig:keypad}
\end{figurehere}


\paragraph{Analog inputs}
The user should also be able to control DJ software parameters with a 
continuous values range. Such values are provided through knobs and sliders.
Electrically, these devices are all potentiometers connected to the ADC module
of the MCU through its analog multiplexer, as shown in \citef{fig:pots_mcu}.
The analog values will then be converted by the ADC and processed by the
\emph{analog inputs task} of the firmware.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=\columnwidth]{images/pots_mcu.pdf}
	\caption{4 potentiometers connected to a MCU, through its built-in analog
	multiplexer and ADC}
	\label{fig:pots_mcu}
\end{figurehere}


\paragraph{Jogwheels}
Jogwheels are fundamentally those developed with the simplified approach at
Section~\ref{sec:simplified_approach}. Each jogwheel is made by a
medium-resolution optical quadrature wheel and its encoder, plus an optical
motion sensor.

The quadrature encoder, thanks to its fairly low speed, can be handled by
MCU interrupt signals (edge-triggered, both signs).

Instead, motion sensors must be connected to the appropriate digital bus
(SSP, SPI), and additional pins to suitable inputs.

Jogwheels should also provide touch-sensitivity, so that a digital signal
(see above) can be generated when the user puts fingers on the wheel.
There are different ways to provide touch sensitivity, but will not be
covered in this document.

In order to shrink the design for low-end controllers, it is possible to
choose a smaller sensor package. For example, the \emph{ADNS-3550} by
\emph{Avago} \cite{avago_adns3550} (see \citef{fig:avago_adns3550}) features
an \emph{ultra slim} design. This may reduce manufacturing costs, because it
integrates the LED, has a very small size, and is suitable for \emph{SMD}
soldering. As a drawback, it is addressed to ultra-low-power wireless devices,
so its performance is worse than the average sensor used for the prototype --
up to 20~in/s at 1000~DPI instead of 30~in/s at 2000~DPI -- but is still
very good for medium-sized jogwheels.

\begin{figurehere}
	\centering
	\includegraphics[keepaspectratio=true,width=0.5\columnwidth]{images/avago_adns3550.jpg}
	\caption{Avago ADNS-3550, an \emph{ultra slim} motion sensor}
	\label{fig:avago_adns3550}
\end{figurehere}


\paragraph{Lights}
Some light can help the user in keeping track of some DJ software states.
Thanks to their very low current consumption and simplicity, LEDs are
always the best choice.

Simple lights can be driven directly by the MCU digital pins, in
any desirable fashion -- could it be direct coupling, LED matrix,
or charlieplexing. These lights can be either on or off.

Dimmed lights are more complex to handle, and need to be connected to PWM
outputs to give an intensity effect to the human eye, proportional to the
PWM duty cycle. Due to scarcity of such outputs, this feature is often not
implemented at all, or applied to simple behaviors -- for example, the
\emph{M-Audio Torq Xponent} \cite{maudio_xponent} gives the so-called
\emph{Christmas tree} effect, with all LEDs beign modulated by the music tempo.


\paragraph{Displays}
Very advanced controllers sometimes provide information through one or more
displays. There are so many display types on the market, that it is difficult
to suggest one. Anyway, for pure text displays, or generally soft-realtime
information visualization, the connection to one among the common UART, I2C,
SPI buses is enough.


%-----------------------------------------------------------------------------
\subsection{Firmware architecture}

The firmware architecture relies on those capabilities given by an RTOS. With
such an operating system, it is possible to divide the firmware into isolated
entities, which collaborate to fulfill the final goal.

Depending on the device being engineered, there is no optimal firmware
architecture, but a general one will be described.


\paragraph{RTOS overview}
A RTOS-based firmware can be split into the following entities: tasks,
drivers, and concurrent data structures.

A \emph{task} is a routine which runs continuously. It can receive, process,
and send data to other entities (tasks or drivers). More tasks can run at the
same time. If it is not possible to run more tasks contemporaneously, the RTOS
must be able to approximate this behavior by an appropriate \emph{scheduling}.
Also, in some scheduling policies a taks is given a \emph{priority}, so that
those with a higher priority can suspend those with a lower one, and take
control of the required resources. Suspendable tasks are called
\emph{preemptive}.

A \emph{driver} is a collection of routines which control peripherals, and
give a standardized abstract interface to the user. A driver can rely on both
tasks and \emph{interrupt service routines}, being seen as part of the OS
-- instead, the user code is always based on tasks, because ISRs are
always processed by drivers.

\emph{Concurrent data structures} are used to exchange data among tasks and
drivers. Because of concurrency, tasks and drivers must be able to exchange
data without corruption, through \emph{atomic} operations. In order to achieve
atomicity, a \emph{locking system} is implemented by such data structures,
handled by the RTOS. These data structures can span from simple semaphores
to complex data queues.

A very important feature of a RTOS is its ability to \emph{schedule} tasks
deterministically. Tasks are often assigned a fixed period, which should
expire with the lowest uncertainity. By choosing a RTOS scheduling policy,
and with a compatible workload, such predictability can be achieved.

A global logical view of the firmware architecture is depicted in
\citef{fig:fw_adv}.

\begin{figure*}[t]
	\centering
	\includegraphics[keepaspectratio=true,scale=0.4]{images/fw_adv.pdf}
	\caption{Logical view of the advanced firmware framework}
	\label{fig:fw_adv}
\end{figure*}


\paragraph{Digital inputs}
Digital inputs are very easy to handle. Supposing a matrix hardware topology,
the \emph{Digital task} simply cycles through all the rows and colums to
detect changes, operations done by the \emph{Digital driver}.

Since in audio applications timing is critical, this loop has to be fast
enough so that the user will not notice delays. The Digital task is pretty
simple, so it can be given high priority, and the cycle period will match
that of HID packets.

The state of digital inputs is held by a double-buffered record, which is then
read by the Controller task.


\paragraph{Analog inputs}
Analog inputs require an \emph{ADC driver} to handle the ADC and its analog
multiplexer.

The \emph{Analog task} polls each analog input for changes. Since human hand
movements have a dynamic rate lower than 10~Hz, a sampling rate of 200~Hz
(5~ms) per channel is enough to keep track of smooth motions. Further
smoothing can be performed with some digital filtering, but is not required.

Like for digital inputs, the state of analog inputs is kept by a
double-buffered record, read by the Controller task.


\paragraph{Lights module}
A module managing lights can be added to the fimware architecture.

A driver will provide a suitable software interface to lights. It might
support simple on/off lights, but also modulated lights. In the case of lights
modulated by PWM outputs, it might lean on the PWM driver of the RTOS.

In the case of charlieplexing, but also for modulation, there is a need to
refresh periodically some hardware peripherals inside a task, to have light
correctly lit. This task could be given a low priority, because delaying the
deadline for a few milliseconds is not that critical. Anyway, the refresh rate
should be high enough to give a smooth transition between light states, around
60~Hz ($\approx$ 16~ms) for the best feeling and user reaction time.

The Controller task tells the state of lights to the Lights task through a
double-buffered record.


\paragraph{Encoder module}
As for the simplified approach, when requiring absolute jogwheel positioning
it is possible to add support for incremental encoders. Such encoders output
quadrature waves, which can be used to increment or decrement some firmware
counters. Again, edge-triggered interrupts should be used to manage counters.

The \emph{Encoder driver} will handle such interrupts, and it will give access
to counters atomically.

The \emph{Encoder task} awaits for interrupt signals by the driver, occurring
when the quadrature wave performs a transition. The internal counter
accumulates the step, so that the absolute position is tracked. This task is
the most critical, because no steps can be lost, and is given the highest
priority with instant response.

The Encoder task tells the current position and deltas to the Controller task
by the use of a double-buffered record.

There can be multiple incremental encoders in the design.


\paragraph{Sensor module}
The sensor module will keep track of the position estimated by the optical
motion sensor.

The \emph{Sensor driver} will communicate to the sensor through the SSP bus,
which in turn is managed by the \emph{SSP driver}.

The \emph{Sensor task} can have different behaviours, depending on the
capabilities of the sensor. If it features a motion interrupt, like the one
chosen for the simplified approach, the sensor awaits for it, then retrieves
the motion delta. If such an interrupt is not present, the Sensor task has to
poll continuously for new data at a very fast rate. This case is typical for
pro-grade sensors, which have a very high framerate, so it is most convenient
to run a tight polling loop at high speed.

The Sensor task tells the current position and deltas to the Controller task
by the use of a double-buffered status record.

There can be multiple optical sensors in the design.


\paragraph{HID/USB module}
In order to communicate with the host the host, HID reports are processed by
the \emph{HID driver}, which in turn is built on top of the \emph{USB driver}.
Such drivers will simplify the packet management by the user, also by
providing a template \emph{HID task}. This task will exchange HID reports
with the Controller task, in the form of plain data records. Such record will
be marshalled and sent to the USB host through the aforementioned drivers.

HID processing should be faster than the report generation of the Controller
task, so the HID task has a higher priority. Also, reaction time should be
minimized.


\paragraph{Console module}
A console module could be added for debug purposes only. By the way, an
advanced hardware debugger is almost always present in MCUs today, so there is
no real need for a debug console inside a consumer DJ controller.

If the console module is added, it needs to be interfaced to the UART through
a driver provided by the RTOS. It also needs a task with low priority in the
case of a simple debug console -- if necessary, immediate commands can always
be issued through the hardware debugger. Response time to incoming messages
should be the shortest possible, as well as outgoing messages should be sent
immediately.

The \emph{Console task} manages console commands and interactions with the
\emph{UART driver}. Messages, in the form of user-friendly data structures,
are exchanged between the Controller and the Console tasks. The latter
performs marshalling with the UART streams. 


\paragraph{Main module}
The main module is composed by the \emph{Controller task}. It collects the
status of user inputs to generate a HID report, handles incoming commands,
sends data to be displayed to screens and lights, and so on. It is the core of
the whole device, which performs all the data processing among the other
modules.

Data collection and HID report generation should occur at most each 1~ms, so
that the latency is minimized to that of USB \emph{Full Speed} interrupt
polling.

The Controller task also manages commands of the Console and Debug tasks,
which must be processed in a very short time -- this is why bare raw data
structures are used instead of strings to be interpreted.


\paragraph{Tasks summary}
The \citet{tab:fw_adv_tasks} summarizes the meaningful settings to be assigned
to tasks inside the chosen RTOS, as described by the previous paragraphs.

Of each task, its \emph{weight} is extimaed, which is a coarse approximation
of the complexity of operations it should perform. It is not a RTOS setting,
but is useful to identify the workload of tasks.

Moreover, the \emph{priority} is intended for a preemptive and priority-based
scheduler, which is common for a state-of-the-art RTOS.

At last, the expected \emph{response time} indicates the target period of the
task routine. For routines heavily based on semaphores -- typically activated
by interrupt signals or software messages -- no delay is expected, so it is
marked as \emph{immediate}.

\begin{tablehere}
\centering \footnotesize
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Task} & \textbf{Weight} & \textbf{Priority} & \textbf{Response time}	\\
\hline
Encoder		& 1	& 5	& immediate	\\
Digital		& 2	& 4	& 1~ms		\\
HID/USB		& 5	& 4	& immediate	\\
Controller	& 4	& 3	& 1~ms		\\
Sensor		& 3	& 3	& immediate	\\
Analog		& 3	& 2	& 5~ms		\\
Console		& 4	& 1	& immediate	\\
Lights		& 2	& 1	& 16~ms		\\
Display		& 5	& 1	& 16~ms		\\
\hline
\end{tabular}
\caption{RTOS settings of tasks}
\label{tab:fw_adv_tasks}
\end{tablehere}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions}
\label{sec:conclusions}

A simplified approach supporting a single jogwheel was developed. Its
performance is suitable for the average DJ, achieving good tracking even with
cheap COTS. Initial motion latency is fairly high, due to the power-saving
states entered by a mouse sensor for wireless appliances, but is still
accetpable. Motions are tracked with outstanding precision and accuracy.
Repeatability is on the average, approximating absolute positioning with some
errors, but still acceptable. An optional incremental encoder can help the
tracking of absolute movements, through some software data processing.
Software can be interfaced to the device with ease, thanks to the adoption of
the HID protocol over the USB bus.

Furthermore, an advanced approach was proposed. It will support not only the
kind of jogwheel presented in the simplified approach, but also peripherals of
various nature. The advanced device needs a more powerful MCU to handle all
those peripherals. In order to make firmware programming more flexible and
easier to manage, a RTOS should be chosen. Thanks to this advanced approach,
it is possible to develope a whole commercial DJ controller, with cheap yet
accurate jogwheels.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{splncs}
\bibliography{Report}

\end{multicols}
\end{document}
